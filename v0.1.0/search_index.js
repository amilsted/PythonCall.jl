var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#You-will-need","page":"Getting Started","title":"You will need","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Julia 1.0 or higher — download here.\nPython 3.5 or higher — download here or set JULIA_PYTHONCALL_EXE=CONDA (see below).","category":"page"},{"location":"getting-started/#Install-the-Julia-package-PythonCall","page":"Getting Started","title":"Install the Julia package PythonCall","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\npkg\"add PythonCall\"","category":"page"},{"location":"getting-started/#Install-the-Python-package-juliacall-(optional)","page":"Getting Started","title":"Install the Python package juliacall (optional)","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This step is only required if you wish to call Julia from Python.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Currently juliacall is shipped with the source of the Julia package, and must be pip-installed manually. The following should work in most shells (including PowerShell):","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pip install $(julia -e \"using PythonCall; print(PythonCall.juliacall_pipdir)\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Alternatively you can just copy the package (at PythonCall.juliacall_dir) to somewhere in your PYTHONPATH.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Note that this is a very small \"bootstrap\" package whose sole job is to locate and load Julia; the main functionality is in the main Julia package. Hence it is not necessary to upgrage juliacall every time you upgrade PythonCall.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Note also that regardless of installing juliacall, a module called juliacall will always be loaded into the interpreter by PythonCall. This means that other Python packages can always import juliacall.","category":"page"},{"location":"getting-started/#Environment-variables","page":"Getting Started","title":"Environment variables","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If Julia and Python are in your PATH, then no further set-up is required. Otherwise, the following environment variables control how the package finds these.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"JULIA_PYTHONCALL_EXE: Path to the Python executable. Or the special value CONDA which uses Python from the default conda environment, or CONDA:{env} to use the given environment. In this case, if conda is not detected then Conda.jl will automatically install miniconda in your Julia depot.\nJULIA_PYTHONCALL_LIB: Path to the Python library. Normally this is inferred from the Python executable, but can be over-ridden.\nPYTHON_JULIACALL_EXE: Path to the Julia executable.\nPYTHON_JULIACALL_LIB: Path to the Julia library. Normally this is inferred from the Julia executable, but can be over-ridden.","category":"page"},{"location":"pythoncall/#The-Julia-module-PythonCall","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"To get started, just do using PythonCall. There are two main ways to use this module:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Way 1: There is a collection of macros for directly executing Python code, interpolating Julia values in and extracting Julia values out. For example @pyv `$x+1`::Int adds x to 1 in Python and converts the result to an Int.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Way 2: There is a collection of functions which typically produce and consume Python objects. The previous example can be implemented as pyadd(Int, x, 1) or pyconvert(Int, PyObject(x)+1).","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"In all cases, when a Julia value needs to be passed to Python, it will be converted according to this table.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"When a Python value is returned to Julia, by default it will be as a PyObject. Most functions provide an optional way to specify the return type, in which case it will be converted according to this table.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"You can also specify one of the wrapper types as a return type.","category":"page"},{"location":"pythoncall/#PyObject","page":"The Julia module PythonCall","title":"PyObject","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"PyObject","category":"page"},{"location":"pythoncall/#PythonCall.PyObject","page":"The Julia module PythonCall","title":"PythonCall.PyObject","text":"PyObject(x)\n\nConvert x to a Python object.\n\nThis is the default type returned by most API functions.\n\nIt supports attribute access (x.attr), indexing (x[i,j], delete!(x, i, j)), calling x(a, b, kw=c), length, iteration (yielding PyObjects), comparisons to other PyObjects (x == y), and arithmetic with other PyObjects and Numbers (x + y, x * 3).\n\nNote that comparisons between PyObjects (==, ≠, ≤, etc.) return PyObject, except isequal and isless which return Bool. Use pyeq and friends to return Bool.\n\nA number of special properties are also defined for convenience to convert the object to another type. To avoid clashes with object attributes, they all have the prefix jl!.\n\nx.jl!(T) is pyconvert(T, x)\nx.jl!i is pyconvert(Int, x)\nx.jl!b is pytruth(x)\nx.jl!s is pystr(String, x).\nx.jl!r is pyrepr(String, x).\nx.jl!f is pyconvert(Float64, x)\nx.jl!c is pyconvert(Complex{Float64}, x)\nx.jl!iter(T=PyObject) is PyIterable{T}(x)\nx.jl!list(T=PyObject) is PyList{T}(x)\nx.jl!set(T=PyObject) is PySet{T}(x)\nx.jl!dict(K=PyObject, V=PyObject) is PyDict{K,V}(x)\nx.jl!io(...) is PyIO(x; ...)\nx.jl!pandasdf(...) is PyPandasDataFrame(x; ...)\nx.jl!buffer(...) is PyBuffer(x, ...)\nx.jl!array(...) is PyArray{...}(x)\nx.jl!vector(...) is PyVector{...}(x)\nx.jl!matrix(...) is PyMatrix{...}(x)\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#Execute-Python-code","page":"The Julia module PythonCall","title":"Execute Python code","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These macros are used to execute or evaluate Python code. The main differences between them are in whether/how any values are extracted out again.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Note to package writers. These all expect there to be a variable pyglobals in scope, which is a Python dictionary giving the global scope. For convenience, this module exports such a variable so that these macros work in the REPL. However other packages should define their own global scope by defining const pyglobals = PyDict(). You can alternatively define const pyglobals = PythonCall.pylazyobject(()->pyimport(\"some_module\").__dict__) to use the global scope of an existing Python module.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"@py\n@pyv\n@pyg\n@pya\n@pyr","category":"page"},{"location":"pythoncall/#PythonCall.@py","page":"The Julia module PythonCall","title":"PythonCall.@py","text":"@py `...` [locals] [var=val, ...]\n\nExecute the given Python code.\n\nJulia values can be interpolated using the usual $(...) syntax.\n\nAdditionally, assignment to interpolations is supported: e.g. $(x::T) = ... will convert the right hand side to a T and assign it to x.\n\nCurrently only single assignment is supported. Multiple assignment ($x, $y = ...) or mutating assignment ($x += ...) will not be recognized.\nWhat actually happens is that the assignment is to a temporary Python variable, which is then read when execution successfully finishes. Hence if an exception occurs, no assignments will happen.\n\nThe globals are pyglobals. The locals are locals, if given, otherwise a temporary scope is created. Extra values to be interted into the scope can be given with extra var=val arguments.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.@pyv","page":"The Julia module PythonCall","title":"PythonCall.@pyv","text":"@pyv `...`[::rettype] [locals] [var=val, ...]\n\nEvaluate the given Python expression and return its value.\n\nJulia values can be interpolated using the usual $(...) syntax.\n\nThe globals are pyglobals. The locals are locals, if given, otherwise a temporary scope is created. Extra values to be interted into the scope can be given with extra var=val arguments.\n\nThe result is converted to a rettype, which defaults to PyObject.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.@pyg","page":"The Julia module PythonCall","title":"PythonCall.@pyg","text":"@pyg `...` [var=val, ...]\n\nExecute the given Python code in the global scope.\n\nThis is simply shorthand for @py `...` pyglobals (see @py).\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.@pya","page":"The Julia module PythonCall","title":"PythonCall.@pya","text":"@pya `...`[::rettype] [locals] [var=val, ...]\n\nExecute the given Python code and return ans.\n\nThis is the same as @py ... except that the variable ans is extracted from the scope and returned.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.@pyr","page":"The Julia module PythonCall","title":"PythonCall.@pyr","text":"@pyr `...`[::rettype] [locals] [var=val, ...]\n\nExecute the given Python code in a function and return its return value.\n\nEssentially equivalent to @pya `def result(): ...; ans = result()`.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#Python-functions","page":"The Julia module PythonCall","title":"Python functions","text":"","category":"section"},{"location":"pythoncall/#Construct-Python-objects","page":"The Julia module PythonCall","title":"Construct Python objects","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions convert Julia values into Python objects of standard types.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pynone\npybool\npyint\npyfloat\npystr\npybytes\npytuple\npylist\npycollist\npyrowlist\npyset\npyfrozenset\npydict\npyslice\npyellipsis\npynotimplemented\npymethod\npytype","category":"page"},{"location":"pythoncall/#PythonCall.pynone","page":"The Julia module PythonCall","title":"PythonCall.pynone","text":"pynone([T=PyObject]) :: T\n\nEquivalent to None in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybool","page":"The Julia module PythonCall","title":"PythonCall.pybool","text":"pybool([T=PyObject,] ...) :: T\n\nEquivalent to bool(...) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyint","page":"The Julia module PythonCall","title":"PythonCall.pyint","text":"pyint([T=PyObject,] ...) :: T\n\nEquivalent to int(...) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfloat","page":"The Julia module PythonCall","title":"PythonCall.pyfloat","text":"pyfloat([T=PyObject,] ...) :: T\n\nEquivalent to float(...) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pystr","page":"The Julia module PythonCall","title":"PythonCall.pystr","text":"pystr([T=PyObject,] x) :: T\n\nEquivalent to str(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybytes","page":"The Julia module PythonCall","title":"PythonCall.pybytes","text":"pybytes([T=PyObject,] x) :: T\n\nEquivalent to str(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytuple","page":"The Julia module PythonCall","title":"PythonCall.pytuple","text":"pytuple([T=PyObject,] [x]) :: T\n\nCreate a Python tuple from the elements of iterable x.\n\nIf x is a Python object, this is equivalent to tuple(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylist","page":"The Julia module PythonCall","title":"PythonCall.pylist","text":"pylist([T=PyObject,] [x]) :: T\n\nCreate a Python list from the elements of iterable x.\n\nIf x is a Python object, this is equivalent to list(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycollist","page":"The Julia module PythonCall","title":"PythonCall.pycollist","text":"pycollist([T=PyObject,] x::AbstractArray) :: T\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of columns.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrowlist","page":"The Julia module PythonCall","title":"PythonCall.pyrowlist","text":"pyrowlist([T=PyObject,] x::AbstractArray) :: T\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of rows.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyset","page":"The Julia module PythonCall","title":"PythonCall.pyset","text":"pyset([T=PyObject,] [x]) :: T\n\nCreate a Python set from the elements of iterable x.\n\nIf x is a Python object, this is equivalent to set(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfrozenset","page":"The Julia module PythonCall","title":"PythonCall.pyfrozenset","text":"pyfrozenset([T=PyObject,] [x]) :: T\n\nCreate a Python frozenset from the elements of iterable x.\n\nIf x is a Python object, this is equivalent to frozenset(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydict","page":"The Julia module PythonCall","title":"PythonCall.pydict","text":"pydict([T=PyObject,] [x]) :: T\npydict([T=PyObject;] key=value, ...)\n\nCreate a Python dict from the given key-value pairs in x or keyword arguments.\n\nIf x is a Python object, this is equivalent to dict(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyslice","page":"The Julia module PythonCall","title":"PythonCall.pyslice","text":"pyslice([T=PyObject,] [start,] stop, [step]) :: T\n\nEquivalent to slice(start, stop, step) in Python (or start:stop:step while indexing).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyellipsis","page":"The Julia module PythonCall","title":"PythonCall.pyellipsis","text":"pyellipsis([T=PyObject]) :: T\n\nEquivalent to Ellipsis in Python (or ... while indexing).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pynotimplemented","page":"The Julia module PythonCall","title":"PythonCall.pynotimplemented","text":"pynotimplemented([T=PyObject]) :: T\n\nEquivalent to NotImplemented in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymethod","page":"The Julia module PythonCall","title":"PythonCall.pymethod","text":"pymethod([T=PyObject,] x) :: T\n\nConvert x to a Python instance method.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytype","page":"The Julia module PythonCall","title":"PythonCall.pytype","text":"pytype([T=PyObject,] x) :: T\n\nEquivalent to type(x) in Python.\n\n\n\n\n\npytype([T=PyObject,] name, bases, dict) :: T\n\nEquivalent to type(name, bases, dict) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Wrap-Julia-values","page":"The Julia module PythonCall","title":"Wrap Julia values","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions wrap Julia values into Python objects, documented here.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyjl\npyjlraw\npyisjl\npyjlgetvalue\npytextio\npyrawio\npybufferedio","category":"page"},{"location":"pythoncall/#PythonCall.pyjl","page":"The Julia module PythonCall","title":"PythonCall.pyjl","text":"pyjl([T=PyObject,] x)\n\nWrap x as a Python juliacall.AnyValue (or subclass) object.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyjlraw","page":"The Julia module PythonCall","title":"PythonCall.pyjlraw","text":"pyjlraw([T=PyObject,] x)\n\nWrap x as a Python juliacall.RawValue object.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisjl","page":"The Julia module PythonCall","title":"PythonCall.pyisjl","text":"pyisjl(o)\n\nTrue if o is a juliacall.ValueBase object.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyjlgetvalue","page":"The Julia module PythonCall","title":"PythonCall.pyjlgetvalue","text":"pyjlgetvalue()\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytextio","page":"The Julia module PythonCall","title":"PythonCall.pytextio","text":"pytextio([T=PyObject], io::IO) :: T\n\nConvert io to a Python text IO stream, specifically a juliacall.TextIOValue.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrawio","page":"The Julia module PythonCall","title":"PythonCall.pyrawio","text":"pyrawio([T=PyObject], io::IO) :: T\n\nConvert io to a Python raw (unbuffered byte) IO stream, specifically a juliacall.RawIOValue.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybufferedio","page":"The Julia module PythonCall","title":"PythonCall.pybufferedio","text":"pybufferedio([T=PyObject], io::IO) :: T\n\nConvert io to a Python buffered byte IO stream, specifically a juliacall.BufferedIOValue.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Python-builtins","page":"The Julia module PythonCall","title":"Python builtins","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyconvert\npyimport\npywith\npyis\npyrepr\npyhasattr\npygetattr\npysetattr\npydir\npycall\npylen\npycontains\npyin\npygetitem\npysetitem\npydelitem\npytruth\npyissubclass\npyisinstance\npyhash\npyiter","category":"page"},{"location":"pythoncall/#PythonCall.pyconvert","page":"The Julia module PythonCall","title":"PythonCall.pyconvert","text":"pyconvert(T, x) :: T\n\nConvert Python object x to a T.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimport","page":"The Julia module PythonCall","title":"PythonCall.pyimport","text":"pyimport([T=PyObject,] name) :: T\npyimport([T=PyObject,] name=>attr) :: T\npyimport([T=PyObject,] name=>(attr,...)) :: Tuple{T,...}\n\nImports and returns the Python module name.\n\nIf additionally attr is given, the given attribute of the module is returned instead. It may also be a tuple of attributes.\n\nIf several arguments are given, each one is imported and a tuple is returned.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pywith","page":"The Julia module PythonCall","title":"PythonCall.pywith","text":"pywith(f, o, d=nothing)\n\nEquivalent to with o as x: f(x) in Python, where x is a PyObject.\n\nOn success, the value of f(x) is returned. If an exception occurs but is suppressed then d is returned.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyis","page":"The Julia module PythonCall","title":"PythonCall.pyis","text":"pyis(x, y) :: Bool\n\nEquivalent to x is y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrepr","page":"The Julia module PythonCall","title":"PythonCall.pyrepr","text":"pyrepr([T=PyObject,] x) :: T\n\nEquivalent to repr(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhasattr","page":"The Julia module PythonCall","title":"PythonCall.pyhasattr","text":"pyhasattr(x, k) :: Bool\n\nEquivalent to hasattr(x, k) in Python, returned as a Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygetattr","page":"The Julia module PythonCall","title":"PythonCall.pygetattr","text":"pygetattr([T=PyObject,] x, k) :: T\n\nEquivalent to x.k or getattr(x, k) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysetattr","page":"The Julia module PythonCall","title":"PythonCall.pysetattr","text":"pysetattr(x, k, v)\n\nEquivalent to x.k = v or setattr(x, k, v) in Python, but returns x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydir","page":"The Julia module PythonCall","title":"PythonCall.pydir","text":"pydir([T=PyObject,] x) :: T\n\nEquivalent to dir(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycall","page":"The Julia module PythonCall","title":"PythonCall.pycall","text":"pycall([T=PyObject,] f, args...; kwargs...) :: T\n\nEquivalent to f(*args, **kwargs) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylen","page":"The Julia module PythonCall","title":"PythonCall.pylen","text":"pylen(x) :: Integer\n\nEquivalent to len(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycontains","page":"The Julia module PythonCall","title":"PythonCall.pycontains","text":"pycontains(x, v) :: Bool\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyin","page":"The Julia module PythonCall","title":"PythonCall.pyin","text":"pyin(v, x) :: Bool\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygetitem","page":"The Julia module PythonCall","title":"PythonCall.pygetitem","text":"pygetitem([T=PyObject,] x, k) :: T\n\nEquivalent to x[k] or getitem(x, k) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysetitem","page":"The Julia module PythonCall","title":"PythonCall.pysetitem","text":"pysetitem(x, k, v)\n\nEquivalent to x[k] = v or setitem(x, k, v) in Python, but returns x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydelitem","page":"The Julia module PythonCall","title":"PythonCall.pydelitem","text":"pydelitem(x, k)\n\nEquivalent to del x[k] or delitem(x, k) in Python, but returns x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytruth","page":"The Julia module PythonCall","title":"PythonCall.pytruth","text":"pytruth(x) :: Bool\n\nThe truthyness of x, equivalent to bool(x) or not not x in Python, or to pybool(Bool, x).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyissubclass","page":"The Julia module PythonCall","title":"PythonCall.pyissubclass","text":"pyissubclass(x, y) :: Bool\n\nEquivalent to issubclass(x, y) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisinstance","page":"The Julia module PythonCall","title":"PythonCall.pyisinstance","text":"pyisinstance(x, y) :: Bool\n\nEquivalent to isinstance(x, y) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhash","page":"The Julia module PythonCall","title":"PythonCall.pyhash","text":"pyhash(x) :: Integer\n\nEquivalent to hash(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiter","page":"The Julia module PythonCall","title":"PythonCall.pyiter","text":"pyiter([T=PyObject] x) :: T\n\nEquivalent to iter(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Numbers","page":"The Julia module PythonCall","title":"Numbers","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyeq\npyne\npyle\npylt\npyge\npygt\npyadd\npyiadd\npysub\npyisub\npymul\npyimul\npymatmul\npyimatmul\npyfloordiv\npyifloordiv\npytruediv\npyitruediv\npymod\npyimod\npydivmod\npylshift\npyilshift\npyrshift\npyirshift\npyand\npyiand\npyor\npyior\npyxor\npyixor\npypow\npyipow\npyneg\npypos\npyabs\npyinv","category":"page"},{"location":"pythoncall/#PythonCall.pyeq","page":"The Julia module PythonCall","title":"PythonCall.pyeq","text":"pyeq([T=PyObject,] x, y) :: T\n\nEquivalent to x == y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyne","page":"The Julia module PythonCall","title":"PythonCall.pyne","text":"pyne([T=PyObject,] x, y) :: T\n\nEquivalent to x != y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyle","page":"The Julia module PythonCall","title":"PythonCall.pyle","text":"pyle([T=PyObject,] x, y) :: T\n\nEquivalent to x <= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylt","page":"The Julia module PythonCall","title":"PythonCall.pylt","text":"pylt([T=PyObject,] x, y) :: T\n\nEquivalent to x < y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyge","page":"The Julia module PythonCall","title":"PythonCall.pyge","text":"pyge([T=PyObject,] x, y) :: T\n\nEquivalent to x >= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygt","page":"The Julia module PythonCall","title":"PythonCall.pygt","text":"pygt([T=PyObject,] x, y) :: T\n\nEquivalent to x > y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyadd","page":"The Julia module PythonCall","title":"PythonCall.pyadd","text":"pyadd([T=PyObject,] x, y) :: T\n\nEquivalent to x + y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiadd","page":"The Julia module PythonCall","title":"PythonCall.pyiadd","text":"pyiadd([T=typeof(x),] x, y) :: T\n\nx = pyiadd(x, y) is equivalent to x += y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysub","page":"The Julia module PythonCall","title":"PythonCall.pysub","text":"pysub([T=PyObject,] x, y) :: T\n\nEquivalent to x - y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisub","page":"The Julia module PythonCall","title":"PythonCall.pyisub","text":"pyisub([T=typeof(x),] x, y) :: T\n\nx = pyisub(x, y) is equivalent to x -= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymul","page":"The Julia module PythonCall","title":"PythonCall.pymul","text":"pymul([T=PyObject,] x, y) :: T\n\nEquivalent to x * y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimul","page":"The Julia module PythonCall","title":"PythonCall.pyimul","text":"pyimul([T=typeof(x),] x, y) :: T\n\nx = pyimul(x, y) is equivalent to x *= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymatmul","page":"The Julia module PythonCall","title":"PythonCall.pymatmul","text":"pymatmul([T=PyObject,] x, y) :: T\n\nEquivalent to x @ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimatmul","page":"The Julia module PythonCall","title":"PythonCall.pyimatmul","text":"pyimatmul([T=typeof(x),] x, y) :: T\n\nx = pyimatmul(x, y) is equivalent to x @= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfloordiv","page":"The Julia module PythonCall","title":"PythonCall.pyfloordiv","text":"pyfloordiv([T=PyObject,] x, y) :: T\n\nEquivalent to x // y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyifloordiv","page":"The Julia module PythonCall","title":"PythonCall.pyifloordiv","text":"pyifloordiv([T=typeof(x),] x, y) :: T\n\nx = pyifloordiv(x, y) is equivalent to x //= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytruediv","page":"The Julia module PythonCall","title":"PythonCall.pytruediv","text":"pytruediv([T=PyObject,] x, y) :: T\n\nEquivalent to x / y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyitruediv","page":"The Julia module PythonCall","title":"PythonCall.pyitruediv","text":"pyitruediv([T=typeof(x),] x, y) :: T\n\nx = pyitruediv(x, y) is equivalent to x /= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymod","page":"The Julia module PythonCall","title":"PythonCall.pymod","text":"pymod([T=PyObject,] x, y) :: T\n\nEquivalent to x % y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimod","page":"The Julia module PythonCall","title":"PythonCall.pyimod","text":"pyimod([T=typeof(x),] x, y) :: T\n\nx = pyimod(x, y) is equivalent to x %= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydivmod","page":"The Julia module PythonCall","title":"PythonCall.pydivmod","text":"pydivmod([T=PyObject,] x, y) :: T\n\nEquivalent to divmod(x, y) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylshift","page":"The Julia module PythonCall","title":"PythonCall.pylshift","text":"pylshift([T=PyObject,] x, y) :: T\n\nEquivalent to x << y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyilshift","page":"The Julia module PythonCall","title":"PythonCall.pyilshift","text":"pyilshift([T=typeof(x),] x, y) :: T\n\nx = pyilshift(x, y) is equivalent to x <<= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrshift","page":"The Julia module PythonCall","title":"PythonCall.pyrshift","text":"pyrshift([T=PyObject,] x, y) :: T\n\nEquivalent to x >> y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyirshift","page":"The Julia module PythonCall","title":"PythonCall.pyirshift","text":"pyirshift([T=typeof(x),] x, y) :: T\n\nx = pyirshift(x, y) is equivalent to x >>= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyand","page":"The Julia module PythonCall","title":"PythonCall.pyand","text":"pyand([T=PyObject,] x, y) :: T\n\nEquivalent to x & y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiand","page":"The Julia module PythonCall","title":"PythonCall.pyiand","text":"pyiand([T=typeof(x),] x, y) :: T\n\nx = pyiand(x, y) is equivalent to x &= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyor","page":"The Julia module PythonCall","title":"PythonCall.pyor","text":"pyor([T=PyObject,] x, y) :: T\n\nEquivalent to x | y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyior","page":"The Julia module PythonCall","title":"PythonCall.pyior","text":"pyior([T=typeof(x),] x, y) :: T\n\nx = pyior(x, y) is equivalent to x |= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyxor","page":"The Julia module PythonCall","title":"PythonCall.pyxor","text":"pyxor([T=PyObject,] x, y) :: T\n\nEquivalent to x ^ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyixor","page":"The Julia module PythonCall","title":"PythonCall.pyixor","text":"pyixor([T=typeof(x),] x, y) :: T\n\nx = pyixor(x, y) is equivalent to x ^= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pypow","page":"The Julia module PythonCall","title":"PythonCall.pypow","text":"pypow([T=PyObject,] x, y, [z]) :: T\n\nEquivalent to x**y or pow(x, y, z) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyipow","page":"The Julia module PythonCall","title":"PythonCall.pyipow","text":"pyipow([T=typeof(x),] x, y, [z]) :: T\n\nx = pyipow(x, y) is equivalent to x **= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyneg","page":"The Julia module PythonCall","title":"PythonCall.pyneg","text":"pyneg([T=typeof(x),] x) :: T\n\nEquivalent to -x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pypos","page":"The Julia module PythonCall","title":"PythonCall.pypos","text":"pypos([T=typeof(x),] x) :: T\n\nEquivalent to +x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyabs","page":"The Julia module PythonCall","title":"PythonCall.pyabs","text":"pyabs([T=typeof(x),] x) :: T\n\nEquivalent to abs(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyinv","page":"The Julia module PythonCall","title":"PythonCall.pyinv","text":"pyinv([T=typeof(x),] x) :: T\n\nEquivalent to -x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#python-wrappers","page":"The Julia module PythonCall","title":"Wrapper types","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"PyList\nPySet\nPyDict\nPyIterable\nPyArray\nPyBuffer\nPyIO\nPyPandasDataFrame\nPyCode\n@py_cmd\n@pyv_cmd\nPyInternedString\n@pystr_str\nPyException","category":"page"},{"location":"pythoncall/#PythonCall.PyList","page":"The Julia module PythonCall","title":"PythonCall.PyList","text":"PyList{T=PyObject}([o])\n\nWrap the Python list o (or anything satisfying the sequence interface) as a Julia vector with elements of type T.\n\nIf o is not given, an empty list is created.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PySet","page":"The Julia module PythonCall","title":"PythonCall.PySet","text":"PySet{T=PyObject}([o])\n\nWrap the Python set o (or anything satisfying the set interface) as a Julia set with elements of type T.\n\nIf o is not given, an empty set is created.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyDict","page":"The Julia module PythonCall","title":"PythonCall.PyDict","text":"PyDict{K=PyObject, V=PyObject}([o])\n\nWrap the Python dictionary o (or anything satisfying the mapping interface) as a Julia dictionary with keys of type K and values of type V.\n\nIf o is not given, an empty dict is created.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyIterable","page":"The Julia module PythonCall","title":"PythonCall.PyIterable","text":"PyIterable{T=PyObject}(o)\n\nWrap the Python object o into a Julia object which iterates values of type T.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyArray","page":"The Julia module PythonCall","title":"PythonCall.PyArray","text":"PyArray{R,N,T,M,L}(o) :: AbstractArray{T,N}\n\nInterpret the Python array o as a Julia array.\n\nThe input may be anything supporting the buffer protocol or the numpy array interface. This includes bytes, bytearray, array.array, numpy.ndarray, pandas.Series.\n\nAll type parameters are optional:\n\nR is the type of elements of the underlying buffer.\nN is the number of dimensions.\nT is the element type.\nM is true if the array is mutable.\nL is true if the array supports fast linear indexing.\n\nThere are alias types with names of the form Py[Mutable/Immutable/][Linear/Cartesian/][Array/Vector/Matrix].\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyBuffer","page":"The Julia module PythonCall","title":"PythonCall.PyBuffer","text":"PyBuffer(o, [flags=C.PyBUF_FULL_RO])\n\nA reference to the underlying buffer of o, if it satisfies the buffer protocol.\n\nHas the following properties:\n\nbuf: Pointer to the data.\nobj: The exporting object (usually o).\nlen: The length of the buffer in bytes.\nreadonly: True if the buffer is immutable.\nitemsize: The size of each element.\nformat: The struct-syntax format of the element type.\nndim: The number of dimensions.\nshape: The length of the buffer in each dimension.\nstrides: The strides (in bytes) of the buffer in each dimension.\nsuboffsets: For indirect arrays. See the buffer protocol documentation.\nisccontiguous: True if the buffer is C-contiguous (e.g. numpy arrays).\nisfcontiguous: True if the buffer is Fortran-contiguous (e.g. Julia arrays).\neltype: The element type.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyIO","page":"The Julia module PythonCall","title":"PythonCall.PyIO","text":"PyIO(o; own=false, text=missing, buflen=4096)\n\nWrap the Python byte-based IO stream o as a Julia IO stream.\n\nWhen this goes out of scope and is finalized, it is automatically flushed. If own=true then it is also closed.\n\nIf text=false then o must be a binary stream and arbitrary binary I/O is possible. If text=true then o must be a text stream and only UTF-8 must be written (i.e. use print not write). If text is not specified then it is chosen automatically. If o is a text stream and you really need a binary stream, then often PyIO(o.buffer) will work.\n\nFor efficiency, reads and writes are buffered before being sent to o. The size of the buffer is buflen.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyPandasDataFrame","page":"The Julia module PythonCall","title":"PythonCall.PyPandasDataFrame","text":"PyPandasDataFrame(o; indexname=:index, columntypes=(), copy=false)\n\nWrap the Pandas dataframe o as a Julia table.\n\nThis object satisfies the Tables.jl and TableTraits.jl interfaces.\n\nindexname: The name of the index column when converting this to a table, and may be nothing to exclude the index.\ncolumntypes: An iterable of columnname=>type or [columnnames...]=>type pairs, used when converting to a table.\ncopy: True to copy columns on conversion.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyCode","page":"The Julia module PythonCall","title":"PythonCall.PyCode","text":"PyCode(code::String, filename::String, mode::Symbol)\n\nA Python code object, representing the compiled contents of code.\n\nThe filename is used for exception printing. The mode must be :exec or :eval.\n\nSee also @py_cmd and @pyv_cmd.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.@py_cmd","page":"The Julia module PythonCall","title":"PythonCall.@py_cmd","text":"py`...` :: PyCode\n\nLiteral syntax for a compiled PyCode object in \"exec\" mode.\n\nSuitable for passing to Python's exec function.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.@pyv_cmd","page":"The Julia module PythonCall","title":"PythonCall.@pyv_cmd","text":"pyv`...` :: PyCode\n\nLiteral syntax for a compiled PyCode object in \"eval\" mode.\n\nSuitable for passing to Python's eval function.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.PyInternedString","page":"The Julia module PythonCall","title":"PythonCall.PyInternedString","text":"PyInternedString(x::String)\n\nConvert x to an interned Python string.\n\nThis can provide a performance boost when using strings to index dictionaries or get attributes.\n\nSee also @pystr_str.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.@pystr_str","page":"The Julia module PythonCall","title":"PythonCall.@pystr_str","text":"pystr\"...\" :: PyInternedString\n\nLiteral syntax for an interned Python string.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.PyException","page":"The Julia module PythonCall","title":"PythonCall.PyException","text":"PyException <: Exception\n\nRepresents an exception raised from Python.\n\nIt has three fields tref, vref, bref which are all PyRefs, and are the type, value and backtrace of the exception.\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Conversion-Rules","page":"Conversion Rules","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"This page documents the rules used to convert values between Julia and Python.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"In both directions, the default behaviour is to allow conversion between immutable values. Mutable values will be \"wrapped\" so that mutations on the wrapper affect the original object.","category":"page"},{"location":"conversion/#jl2py","page":"Conversion Rules","title":"Julia to Python","text":"","category":"section"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"When a Julia object is converted to a Python one (e.g. by calling PyObject, by interpolating it into a @py command, or passing it as an argument to a Python function) the following rules are used by default.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The user can always explicitly choose a different conversion (e.g. by calling pylist or pydict).","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From To\nAny Python object type (PyObject, PyList, etc.) itself\nNothing, Missing None\nBool bool\nStandard integer (IntXX, UIntXX, BigInt) int\nStandard rational (Rational{T}, T a standard integer) fractions.Fraction\nStandard float (FloatXX) float\nStandard complex (Complex{T}, T a standard float) complex\nStandard string/char (String and SubString{String}, Char) str\nTuple tuple\nStandard integer range (AbstractRange{T}, T a standard integer) range\nDate, Time, DateTime (from Dates) date, time, datetime (from datetime)\nSecond, Millisecond, Microsecond, Nanosecond (from Dates) timedelta (from datetime)\nNumber juliacall.NumberValue, juliacall.ComplexValue, etc.\nAbstractArray juliacall.ArrayValue, juliacall.VectorValue\nAbstractDict juliacall.DictValue\nAbstractSet juliacall.SetValue\nIO juliacall.BufferedIOValue\nModule juliacall.ModuleValue\nType juliacall.TypeValue\nAnything else juliacall.AnyValue","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The juliacall.*Value types are all subtypes of juliacall.AnyValue. They wrap a Julia value, providing access to Julia semantics: it can be called, indexed, and so on. Subtypes add additional Pythonic semantics. Read more here.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"This conversion policy is defined/implemented by PythonCall.C.PyObject_From and PythonCall.C.PyJuliaValue_From. Package authors can (carefully) overload these with additional rules for custom types.","category":"page"},{"location":"conversion/#py2jl","page":"Conversion Rules","title":"Python to Julia","text":"","category":"section"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From Julia, one can convert Python objects to a desired type using pyconvert(T, x) for example, or @pyv `...`::T.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From Python, when a value is passed to Julia, it is typically converted to a corresponding Julia value using pyconvert(Any, x).","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"Quite general conversions are allowed, and the target type T can be as specific as you like. For example","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"@pyv `[1, None, 3]`::Tuple{Vararg{Union{AbstractFloat,Missing}}}","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"evaluates to (1.0, missing, 2.0).","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The following table specifies the conversion rules in place. If the initial Python type matches the \"From\" column and the desired type T intersects with the \"To\" column, then that conversion is attempted. Conversions are tried in priority order, then in specificity order.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From To\nTop priority (wrapped values). \njuliacall.AnyValue Any\nVery high priority (arrays). \nObjects satisfying the buffer or array interface (inc. bytes, bytearray, array.array, numpy.ndarray) PyArray\nHigh priority (canonical conversions). \nNone Nothing\nbool Bool\nnumbers.Integral (inc. int) Integer (prefers Int, or BigInt on overflow)\nfloat Float64\ncomplex Complex{Float64}\nrange StepRange\nstr String\ntuple Tuple\ncollections.abc.Mapping (inc. dict) PyDict\ncollections.abc.Sequence (inc. list) PyList\ncollections.abc.Set (inc. set, frozenset) PySet\nio.IOBase (includes open files) PyIO\ndatetime.date/datetime.time/datetime.datetime Date/Time/DateTime\ndatetime.timedelta Microsecond (or Millisecond or Second on overflow)\nnumpy.intXX/numpy.uintXX/numpy.floatXX IntXX/UIntXX/FloatXX\nStandard priority (other reasonable conversions). \nNone Missing\nbytes Vector{UInt8}, Vector{Int8}, String\nstr String, Symbol, Char, Vector{UInt8}, Vector{Int8}\nrange UnitRange\ncollections.abc.Mapping Dict\ncollections.abc.Iterable Vector, Set, Tuple, NamedTuple, Pair\ndatetime.timedelta Dates.CompoundPeriod\nnumbers.Integral Integer, Rational, Real, Number\nnumbers.Real AbstractFloat, Number\nnumbers.Complex Complex, Number\nctypes.c_int and other integers Integer, Rational, Real, Number\nctypes.c_float/ctypes.c_double Cfloat/Cdouble, AbstractFloat, Real, Number\nctypes.c_voidp Ptr{Cvoid}, Ptr\nctypes.c_char_p Cstring, Ptr{Cchar}, Ptr\nctypes.c_wchar_p Cwstring, Ptr{Cwchar}, Ptr\nnumpy.intXX/numpy.uintXX/numpy.floatXX Integer, Rational, Real, Number\nLow priority (fallback to PyObject). \nAnything PyObject\nBottom priority (must be explicitly specified by excluding PyObject). \nObjects satisfying the buffer interface PyBuffer\nAnything PyRef","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"Package authors can (carefully) add extra rules by calling PythonCall.C.PyObject_TryConvert_AddRule in __init__.","category":"page"},{"location":"juliacall/#The-Python-module-juliacall","page":"The Python module juliacall","title":"The Python module juliacall","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"For interactive or scripting use, the simplest way to get started is:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"from juliacall import Main as jl","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"This loads a single variable jl (a ModuleValue) which represents the Main module in Julia, from which all of Julia's functionality is available.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"If you are writing a package which uses Julia, then to avoid polluting the global Main namespace you should do:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"import juliacall; jl = juliacall.newmodule(\"SomeName\");","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"Now you can do jl.rand(jl.Bool, 5, 5), which is equivalent to rand(Bool, 5, 5) in Julia.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"When a Python value is passed to Julia, then typically it will be converted according to this table with T=Any. Sometimes a more specific type will be used, such as when assigning to an array whose element type is known.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"When a Julia value is returned to Python, it will normally be converted according to this table.","category":"page"},{"location":"juliacall/#julia-wrappers","page":"The Python module juliacall","title":"Wrapper types","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"Apart from a few fundamental immutable types (see here), all Julia values are by default converted into Python to some AnyValue object, which wraps the original value. Some types are converted to a subclass of AnyValue which provides additional Python semantics –- e.g. Julia vectors are interpreted as Python sequences.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"There is also a RawValue object, which gives a stricter \"Julia-only\" interface, documented below. These types all inherit from ValueBase:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"ValueBase\nRawValue\nAnyValue\nNumberValue\nComplexValue\nRealValue\nRationalValue\nIntegerValue\nArrayValue\nVectorValue\nDictValue\nSetValue\nIOValue\nRawIOValue\nBufferedIOValue\nTextIOValue\nModuleValue\nTypeValue","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.AnyValue - Class\n\nWraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports `repr(x)`, `str(x)`, attributes (`x.attr`), calling (`x(a,b)`), iteration, comparisons, `len(x)`, `a in x`, `dir(x)`.\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to [this table](@ref jl2py). This is typically a builtin Python type (for immutables) or a subtype of `AnyValue`.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, `_b` at the end of an attribute is replaced with `!` and `_bb` is replaced with `!!`.\n\n###### Members\n- `_jl_raw()`: Convert to a [`RawValue`](#juliacall.RawValue). (See also [`pyjlraw`](@ref).)\n- `_jl_display()`: Display the object using Julia's display mechanism.\n- `_jl_help()`: Display help for the object.","category":"page"},{"location":"juliacall/#juliacall.AnyValue","page":"The Python module juliacall","title":"juliacall.AnyValue","text":"Wraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), iteration, comparisons, len(x), a in x, dir(x).\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to this table. This is typically a builtin Python type (for immutables) or a subtype of AnyValue.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, _b at the end of an attribute is replaced with ! and _bb is replaced with !!.\n\nMembers\n\n_jl_raw(): Convert to a RawValue. (See also pyjlraw.)\n_jl_display(): Display the object using Julia's display mechanism.\n_jl_help(): Display help for the object.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.NumberValue - Class\n\nThis wraps any Julia `Number` value. It is a subclass of `numbers.Number` and behaves similar to other Python numbers.\n\nThere are also subtypes `ComplexValue`, `RealValue`, `RationalValue`, `IntegerValue` which wrap values of the corresponding Julia types, and are subclasses of the corresponding `numbers` ABC.","category":"page"},{"location":"juliacall/#juliacall.NumberValue","page":"The Python module juliacall","title":"juliacall.NumberValue","text":"This wraps any Julia Number value. It is a subclass of numbers.Number and behaves similar to other Python numbers.\n\nThere are also subtypes ComplexValue, RealValue, RationalValue, IntegerValue which wrap values of the corresponding Julia types, and are subclasses of the corresponding numbers ABC.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.ArrayValue - Class\n\nThis wraps any Julia `AbstractArray` value. It is a subclass of `collections.abc.Collection`.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nThere is also the subtype `VectorValue` which wraps any `AbstractVector`. It is a subclass of `collections.abc.Sequence` and behaves similar to a Python `list`.\n\nIf the array is strided and its eltype is supported (i.e. `Bool`, `IntXX`, `UIntXX`, `FloatXX`, `Complex{FloatXX}`, `Ptr{Cvoid}` or `Tuple` or `NamedTuple` of these) then it supports the buffer protocol and the numpy array interface. This means that `numpy.asarray(this)` will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy `__array__` method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, `numpy.asarray(this)` is a copy of the original array.\n\n###### Members\n- `ndim`: The number of dimensions.\n- `shape`: Tuple of lengths in each dimension.\n- `copy()`: A copy of the array.\n- `reshape(shape)`: A reshaped view of the array.","category":"page"},{"location":"juliacall/#juliacall.ArrayValue","page":"The Python module juliacall","title":"juliacall.ArrayValue","text":"This wraps any Julia AbstractArray value. It is a subclass of collections.abc.Collection.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nThere is also the subtype VectorValue which wraps any AbstractVector. It is a subclass of collections.abc.Sequence and behaves similar to a Python list.\n\nIf the array is strided and its eltype is supported (i.e. Bool, IntXX, UIntXX, FloatXX, Complex{FloatXX}, Ptr{Cvoid} or Tuple or NamedTuple of these) then it supports the buffer protocol and the numpy array interface. This means that numpy.asarray(this) will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy __array__ method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, numpy.asarray(this) is a copy of the original array.\n\nMembers\n\nndim: The number of dimensions.\nshape: Tuple of lengths in each dimension.\ncopy(): A copy of the array.\nreshape(shape): A reshaped view of the array.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.DictValue - Class\nThis wraps any Julia `AbstractDict` value. It is a subclass of `collections.abc.Mapping` and behaves similar to a Python `dict`.","category":"page"},{"location":"juliacall/#juliacall.DictValue","page":"The Python module juliacall","title":"juliacall.DictValue","text":"This wraps any Julia AbstractDict value. It is a subclass of collections.abc.Mapping and behaves similar to a Python dict.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.SetValue - Class\nThis wraps any Julia `AbstractSet` value. It is a subclass of `collections.abc.Set` and behaves similar to a Python `set`.","category":"page"},{"location":"juliacall/#juliacall.SetValue","page":"The Python module juliacall","title":"juliacall.SetValue","text":"This wraps any Julia AbstractSet value. It is a subclass of collections.abc.Set and behaves similar to a Python set.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.IOValue - Class\n\nThis wraps any Julia `IO` value. It is a subclass of `io.IOBase` and behaves like Python files.\n\nThere are also subtypes `RawIOValue`, `BufferedIOValue` and `TextIOValue`, which are subclasses of `io.RawIOBase` (unbuffered bytes), `io.BufferedIOBase` (buffered bytes) and `io.TextIOBase` (text).\n\n###### Members\n- `torawio()`: Convert to a `RawIOValue`, an un-buffered bytes file-like object. (See also [`pyrawio`](@ref).)\n- `tobufferedio()`: Convert to a `BufferedIOValue`, an buffered bytes file-like object. Julia `IO` objects are converted to this by default. (See also [`pybufferedio`](@ref).)\n- `totextio()`: Convert to a `TextIOValue`, a text file-like object. (See also [`pytextio`](@ref).)","category":"page"},{"location":"juliacall/#juliacall.IOValue","page":"The Python module juliacall","title":"juliacall.IOValue","text":"This wraps any Julia IO value. It is a subclass of io.IOBase and behaves like Python files.\n\nThere are also subtypes RawIOValue, BufferedIOValue and TextIOValue, which are subclasses of io.RawIOBase (unbuffered bytes), io.BufferedIOBase (buffered bytes) and io.TextIOBase (text).\n\nMembers\n\ntorawio(): Convert to a RawIOValue, an un-buffered bytes file-like object. (See also pyrawio.)\ntobufferedio(): Convert to a BufferedIOValue, an buffered bytes file-like object. Julia IO objects are converted to this by default. (See also pybufferedio.)\ntotextio(): Convert to a TextIOValue, a text file-like object. (See also pytextio.)\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.ModuleValue - Class\nThis wraps any Julia `Module` value.\n\nIt is the same as [`AnyValue`](#juliacall.AnyValue) except for one additional convenience method:\n- `seval([module=self], code)`: Evaluates the given code (a string) in the given module.","category":"page"},{"location":"juliacall/#juliacall.ModuleValue","page":"The Python module juliacall","title":"juliacall.ModuleValue","text":"This wraps any Julia Module value.\n\nIt is the same as AnyValue except for one additional convenience method:\n\nseval([module=self], code): Evaluates the given code (a string) in the given module.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.TypeValue - Class\n\nThis wraps any Julia `Type` value.\n\nIt is the same as [`AnyValue`](#juliacall.AnyValue) except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\n```python\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n```","category":"page"},{"location":"juliacall/#juliacall.TypeValue","page":"The Python module juliacall","title":"juliacall.TypeValue","text":"This wraps any Julia Type value.\n\nIt is the same as AnyValue except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.RawValue - Class\n\nWraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports `repr(x)`, `str(x)`, attributes (`x.attr`), calling (`x(a,b)`), `len(x)`, `dir(x)`.\n\nThis is very similar to [`AnyValue`](#juliacall.AnyValue) except that indexing, calling, etc. will always return a `RawValue`.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\n###### Members\n- `_jl_any()`: Convert to a [`AnyValue`](#juliacall.AnyValue) (or subclass). (See also [`pyjl`](@ref).)","category":"page"},{"location":"juliacall/#juliacall.RawValue","page":"The Python module juliacall","title":"juliacall.RawValue","text":"Wraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), len(x), dir(x).\n\nThis is very similar to AnyValue except that indexing, calling, etc. will always return a RawValue.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\nMembers\n\n_jl_any(): Convert to a AnyValue (or subclass). (See also pyjl.)\n\n","category":"class"},{"location":"juliacall/#Utilities","page":"The Python module juliacall","title":"Utilities","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.newmodule - Function\n\n```python\nnewmodule(name)\n```\n\nA new module with the given name.","category":"page"},{"location":"juliacall/#juliacall.newmodule","page":"The Python module juliacall","title":"juliacall.newmodule","text":"newmodule(name)\n\nA new module with the given name.\n\n","category":"function"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.As - Class\n\n```python\nAs(x, T)\n```\n\nWhen passed as an argument to a Julia function, is interpreted as `x` converted to Julia type `T`.","category":"page"},{"location":"juliacall/#juliacall.As","page":"The Python module juliacall","title":"juliacall.As","text":"As(x, T)\n\nWhen passed as an argument to a Julia function, is interpreted as x converted to Julia type T.\n\n","category":"class"},{"location":"compat/#Compatability-Tools","page":"Compatability Tools","title":"Compatability Tools","text":"","category":"section"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"Some packages require a little extra help to work nicely from PythonCall.jl.","category":"page"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"Some of these are \"fixes\" that are silently applied for you, and some are just extra functions to bridge a gap. We aim to keep these as minimal as possible.","category":"page"},{"location":"compat/#Stdlib","page":"Compatability Tools","title":"Stdlib","text":"","category":"section"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"Whenever a Python exception is displayed by Julia, sys.last_traceback and friends are set. This allows the post-mortem debugger pdb.pm() to work. Disable by setting PythonCall.CONFIG.sysautolasttraceback = false.","category":"page"},{"location":"compat/#Tabular-data-and-Pandas","page":"Compatability Tools","title":"Tabular data & Pandas","text":"","category":"section"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"A pandas.DataFrame can be wrapped in Julia as a PyPandasDataFrame, providing a Tables.jl-compatible interface.","category":"page"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"In the other direction, the following functions can be used to convert any Tables.jl-compatible table to a Python table.","category":"page"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"pycolumntable\npyrowtable\npypandasdataframe","category":"page"},{"location":"compat/#PythonCall.pycolumntable","page":"Compatability Tools","title":"PythonCall.pycolumntable","text":"pycolumntable([T=PyObject,] src) :: T\n\nConstruct a \"column table\" from the Tables.jl-compatible table src, namely a Python dict mapping column names to column vectors.\n\n\n\n\n\n","category":"function"},{"location":"compat/#PythonCall.pyrowtable","page":"Compatability Tools","title":"PythonCall.pyrowtable","text":"pyrowtable([T=PyObject,] src) :: T\n\nConstruct a \"row table\" from the Tables.jl-compatible table src, namely a Python list of rows, each row being a Python dict mapping column names to values.\n\n\n\n\n\n","category":"function"},{"location":"compat/#PythonCall.pypandasdataframe","page":"Compatability Tools","title":"PythonCall.pypandasdataframe","text":"pypandasdataframe([T=PyObject,] [src]; ...) :: T\n\nConstruct a pandas dataframe from src.\n\nUsually equivalent to pyimport(\"pandas\").DataFrame(src, ...), but src may also be Tables.jl-compatible table.\n\n\n\n\n\n","category":"function"},{"location":"compat/#MatPlotLib-/-PyPlot","page":"Compatability Tools","title":"MatPlotLib / PyPlot","text":"","category":"section"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"pyplotshow","category":"page"},{"location":"compat/#PythonCall.pyplotshow","page":"Compatability Tools","title":"PythonCall.pyplotshow","text":"pyplotshow([fig]; close=true, [format])\n\nShow the matplotlib/pyplot/seaborn/etc figure fig, or all open figures if not given, using Julia's display mechanism.\n\nIf close is true, the figure is also closed.\n\nThe format specifies the file format of the generated image. By default this is pyplot.rcParams[\"savefig.format\"]. It can be one of \"png\", \"jpg\", \"jpeg\", \"tif\", \"tiff\", \"svg\" or \"pdf\".\n\n\n\n\n\n","category":"function"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"If Julia is running an IJulia kernel, pyplotshow() is automatically called after executing a cell, so that plots generated in a cell are always shown (similar to IPython). It can be disabled by setting PythonCall.CONFIG.pyplotautoshow = false.","category":"page"},{"location":"compat/#GUIs-(including-MatPlotLib)","page":"Compatability Tools","title":"GUIs (including MatPlotLib)","text":"","category":"section"},{"location":"compat/#Event-loops","page":"Compatability Tools","title":"Event loops","text":"","category":"section"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"If for example you wish to use PyPlot in interactive mode (matplotlib.pyplot.ion()) then activating the correct event loop will allow it to work.","category":"page"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"PythonCall.event_loop_on\nPythonCall.event_loop_off","category":"page"},{"location":"compat/#PythonCall.event_loop_on","page":"Compatability Tools","title":"PythonCall.event_loop_on","text":"event_loop_on(g::Symbol; interval=40e-3, fix=false)\n\nActivate an event loop for the GUI framework g, so that the framework can run in the background of a Julia session.\n\nThe event loop runs every interval seconds. If fix is true and g is a Qt framework, then fix_qt_plugin_path is called.\n\nSupported values of g (and the Python module they relate to) are: :pyqt4 (PyQt4), :pyqt5 (PyQt5), :pyside (PySide), :pyside2 (PySide2), :gtk (gtk), :gtk3 (gi), :wx (wx), :tkinter (tkinter).\n\n\n\n\n\n","category":"function"},{"location":"compat/#PythonCall.event_loop_off","page":"Compatability Tools","title":"PythonCall.event_loop_off","text":"event_loop_off(g::Symbol)\n\nTerminate the event loop g if it is running.\n\n\n\n\n\n","category":"function"},{"location":"compat/#Interaction","page":"Compatability Tools","title":"Interaction","text":"","category":"section"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"The following is an alternative to using event loops to enable interactive plotting.","category":"page"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"pyinteract","category":"page"},{"location":"compat/#PythonCall.pyinteract","page":"Compatability Tools","title":"PythonCall.pyinteract","text":"pyinteract(; force=false, sleep=0.1)\n\nSome Python GUIs can work interactively, meaning the GUI is available but the interactive prompt is returned (e.g. after calling matplotlib.pyplot.ion()). To use these from Julia, currently you must manually call pyinteract() each time you want to interact.\n\nInternally, this is calling the PyOS_InputHook asynchronously. Only one copy is run at a time unless force is true.\n\nThe asynchronous task waits for sleep seconds before calling the hook function. This gives time for the next prompt to be printed and waiting for input. As a result, there will be a small delay before the GUI becomes interactive.\n\n\n\n\n\n","category":"function"},{"location":"compat/#Qt-path-fix","page":"Compatability Tools","title":"Qt path fix","text":"","category":"section"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"PythonCall.fix_qt_plugin_path","category":"page"},{"location":"compat/#PythonCall.fix_qt_plugin_path","page":"Compatability Tools","title":"PythonCall.fix_qt_plugin_path","text":"fix_qt_plugin_path()\n\nTry to set the QT_PLUGIN_PATH environment variable in Python, if not already set.\n\nThis fixes the problem that Qt does not know where to find its qt.conf file, because it always looks relative to sys.executable, which can be the Julia executable not the Python one when using this package.\n\nIf CONFIG.qtfix is true, then this is run automatically before PyQt4, PyQt5, PySide or PySide2 are imported.\n\n\n\n\n\n","category":"function"},{"location":"compat/#IPython","page":"Compatability Tools","title":"IPython","text":"","category":"section"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"If Python is running an IPython kernel, then:","category":"page"},{"location":"compat/","page":"Compatability Tools","title":"Compatability Tools","text":"Julia's Base.stdout is set to Python's sys.stdout.\nAn IPythonDisplay is pushed onto Julia's display stack, so that display(x) goes to IPython if possible.","category":"page"},{"location":"#PythonCall.jl","page":"Home","title":"PythonCall.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bringing Python® and Julia together in seamless harmony:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Call Python code from Julia and Julia code from Python via a symmetric interface.\nSimple syntax, so the Python code looks like Python and the Julia code looks like Julia.\nIntuitive and flexible conversions between Julia and Python: anything can be converted, you are in control.\nFast non-copying conversion of numeric arrays in either direction: modify Python arrays (e.g. bytes, array.array, numpy.ndarray) from Julia or Julia arrays from Python.\nHelpful wrappers: interpret Python sequences, dictionaries, arrays, dataframes and IO streams as their Julia couterparts, and vice versa.\nBeautiful stack-traces.\nWorks anywhere: tested on Windows, MacOS and Linux, 32- and 64-bit, Julia 1.0 upwards and Python 3.5 upwards.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is actually two modules working together: a Julia one called PythonCall and a tiny Python one called juliacall.","category":"page"},{"location":"pycall/#Comparison-to-PyCall","page":"Comparison to PyCall","title":"Comparison to PyCall","text":"","category":"section"},{"location":"pycall/","page":"Comparison to PyCall","title":"Comparison to PyCall","text":"The existing package PyCall is another similar interface to Python. Here is a comparison of the designs:","category":"page"},{"location":"pycall/","page":"Comparison to PyCall","title":"Comparison to PyCall","text":"Flexibility of conversion. The mechanisms for data conversion from Python to Julia are different. In PyCall, conversion to T (via convert(T,::PyObject)) essentially only takes T into account, so for example when T=Real then the input will always be converted to a Python float, which is then converted to a Cdouble. In PythonCall, conversion takes into account both the target type T and the Python type of the Python object, and an extensible system allows one to declare conversions for any combination. Many conversions for overlapping combinations can be defined and the most specific one takes precedence. Hence in PythonCall, converting to a Real might return an Int (e.g. the input is a int), or Cdouble (e.g. the input is float), or Rational{BigInt}, or...\nLossiness of conversion from Python. In PyCall, the default PyAny conversion from Python to Julia can be lossy in the sense that it is impossible to recover the original value exactly. For example a list of ints is converted to a Vector{Int} which is a copy of the data, and therefore modifying the original list is not possible. It is also a source of off-by-one errors, since Vector and list have different indexing semantics. In PythonCall, the default conversion is to PyObject (non-lossy), and even if you convert to Any then by default this will be non-lossy: for example a list will be converted to a PyList which is a Vector-like view of the list.\nLossiness of conversion to Python. Similarly, in PyCall the default conversion from Julia to Python can be lossy: a Vector{Int} will be converted to a list of ints for example, losing mutability of the original vector. In PythonCall, only immutable values are truly converted to Python, everything else is wrapped into a Python wrapper around the Julia value: a Vector{Int} is wrapped into a juliacall.VectorValue which is a list-like sequence type\nAutomatic conversion. In PyCall, most function calls, attribute accesses, indexing, etc. of Python objects by default automatically convert their result to a Julia type. In PythonCall the default is to always return PyObject. The latter behaviour provides type-stability. It also makes interacting with Python values more predictable and allows generic programming (where the type of the result is not known). It also allows the user to pick another type to convert to after the fact, whereas since PyCall conversion can be lossy, this is sometimes not possible there.\nBuilding. PyCall locates libpython in its build step, so that it is a const in the module code. This makes ccalls and the like straightforward. PythonCall does this at run-time, which slightly complicates the code (although it is abstracted away) but means that the module does not need to be rebulit for different Python versions.\nDefault Python. By default PyCall uses the version of Python in conda and will silently install miniconda for you if it doesn't exist. PythonCall by default simply uses the version of Python in the PATH. Both are customizable through environment variables.\nPython modules. PyCall has a companion Python module julia for calling Julia from Python. So does PythonCall, but called juliacall. Both of them use PyCall/PythonCall under the hood on the Julia side. The PyCall one is itself about as complex in implementation as PyCall. The PythonCall one is about 50 lines of code (essentially just finding and loading libjulia and the PythonCall module) and provides a single simple entrypoint: the julia Main module.\nCompatability. PyCall supports Julia 0.7+ and Python 2.7+, whereas PythonCall supports Julia 1.0+ and Python 3.5+. PyCall requires numpy to be installed, PythonCall doesn't (it provides the same fast array access through the buffer protocol and array interface).\nStartup time. PythonCall takes longer to start than PyCall, largely because there are a lot of wrapper types (juliacall.AnyValue etc.) to compile.","category":"page"}]
}
