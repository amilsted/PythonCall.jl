<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Comparison to PyCall · PythonCall.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PythonCall.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PythonCall.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../pythoncall/">The Julia module <code>PythonCall</code></a></li><li><a class="tocitem" href="../juliacall/">The Python module <code>juliacall</code></a></li><li><a class="tocitem" href="../conversion/">Conversion Rules</a></li><li><a class="tocitem" href="../compat/">Compatability Tools</a></li><li class="is-active"><a class="tocitem" href>Comparison to PyCall</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Comparison to PyCall</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Comparison to PyCall</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cjdoris/PythonCall.jl/blob/master/docs/src/pycall.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Comparison-to-PyCall"><a class="docs-heading-anchor" href="#Comparison-to-PyCall">Comparison to PyCall</a><a id="Comparison-to-PyCall-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-to-PyCall" title="Permalink"></a></h1><p>The existing package <a href="https://github.com/JuliaPy/PyCall.jl"><code>PyCall</code></a> is another similar interface to Python. Here is a comparison of the designs:</p><ul><li><strong>Flexibility of conversion.</strong> The mechanisms for data conversion from Python to Julia are different. In <code>PyCall</code>, conversion to <code>T</code> (via <code>convert(T,::PyObject)</code>) essentially only takes <code>T</code> into account, so for example when <code>T=Real</code> then the input will always be converted to a Python <code>float</code>, which is then converted to a <code>Cdouble</code>. In <code>PythonCall</code>, conversion takes into account both the target type <code>T</code> and the Python type of the Python object, and an extensible system allows one to declare conversions for any combination. Many conversions for overlapping combinations can be defined and the most specific one takes precedence. Hence in <code>PythonCall</code>, converting to a <code>Real</code> might return an <code>Int</code> (e.g. the input is a <code>int</code>), or <code>Cdouble</code> (e.g. the input is <code>float</code>), or <code>Rational{BigInt}</code>, or...</li><li><strong>Lossiness of conversion from Python.</strong> In <code>PyCall</code>, the default <code>PyAny</code> conversion from Python to Julia can be lossy in the sense that it is impossible to recover the original value exactly. For example a list of ints is converted to a <code>Vector{Int}</code> which is a copy of the data, and therefore modifying the original list is not possible. It is also a source of off-by-one errors, since <code>Vector</code> and <code>list</code> have different indexing semantics. In <code>PythonCall</code>, the default conversion is to <code>PyObject</code> (non-lossy), and even if you convert to <code>Any</code> then by default this will be non-lossy: for example a <code>list</code> will be converted to a <code>PyList</code> which is a <code>Vector</code>-like view of the list.</li><li><strong>Lossiness of conversion to Python.</strong> Similarly, in <code>PyCall</code> the default conversion from Julia to Python can be lossy: a <code>Vector{Int}</code> will be converted to a <code>list</code> of <code>int</code>s for example, losing mutability of the original vector. In <code>PythonCall</code>, only immutable values are truly converted to Python, everything else is wrapped into a Python wrapper around the Julia value: a <code>Vector{Int}</code> is wrapped into a <code>juliacall.VectorValue</code> which is a <code>list</code>-like sequence type</li><li><strong>Automatic conversion.</strong> In <code>PyCall</code>, most function calls, attribute accesses, indexing, etc. of Python objects by default automatically convert their result to a Julia type. In <code>PythonCall</code> the default is to always return <code>PyObject</code>. The latter behaviour provides type-stability. It also makes interacting with Python values more predictable and allows generic programming (where the type of the result is not known). It also allows the user to pick another type to convert to after the fact, whereas since <code>PyCall</code> conversion can be lossy, this is sometimes not possible there.</li><li><strong>Building.</strong> <code>PyCall</code> locates libpython in its build step, so that it is a <code>const</code> in the module code. This makes <code>ccall</code>s and the like straightforward. <code>PythonCall</code> does this at run-time, which slightly complicates the code (although it is abstracted away) but means that the module does not need to be rebulit for different Python versions.</li><li><strong>Default Python.</strong> By default <code>PyCall</code> uses the version of Python in <code>conda</code> and will silently install <code>miniconda</code> for you if it doesn&#39;t exist. <code>PythonCall</code> by default simply uses the version of Python in the PATH. Both are customizable through environment variables.</li><li><strong>Python modules.</strong> <code>PyCall</code> has a companion Python module <code>julia</code> for calling Julia from Python. So does <code>PythonCall</code>, but called <code>juliacall</code>. Both of them use <code>PyCall</code>/<code>PythonCall</code> under the hood on the Julia side. The <code>PyCall</code> one is itself about as complex in implementation as <code>PyCall</code>. The <code>PythonCall</code> one is about 50 lines of code (essentially just finding and loading libjulia and the PythonCall module) and provides a single simple entrypoint: the julia <code>Main</code> module.</li><li><strong>Compatability.</strong> <code>PyCall</code> supports Julia 0.7+ and Python 2.7+, whereas <code>PythonCall</code> supports Julia 1.0+ and Python 3.5+. <code>PyCall</code> requires <code>numpy</code> to be installed, <code>PythonCall</code> doesn&#39;t (it provides the same fast array access through the buffer protocol and array interface).</li><li><strong>Startup time.</strong> <code>PythonCall</code> takes longer to start than <code>PyCall</code>, largely because there are a lot of wrapper types (<code>juliacall.AnyValue</code> etc.) to compile.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compat/">« Compatability Tools</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 March 2021 21:49">Thursday 4 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
