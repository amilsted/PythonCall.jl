<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Coming from PyCall? · PythonCall &amp; juliacall</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PythonCall &amp; juliacall logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PythonCall &amp; juliacall</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../pythoncall/">The Julia module <em>PythonCall</em></a></li><li><a class="tocitem" href="../juliacall/">The Python module <em>juliacall</em></a></li><li><a class="tocitem" href="../conversion-to-python/">Conversion to Python</a></li><li><a class="tocitem" href="../conversion-to-julia/">Conversion to Julia</a></li><li><a class="tocitem" href="../compat/">Compatibility Tools</a></li><li class="is-active"><a class="tocitem" href>Coming from <em>PyCall</em>?</a><ul class="internal"><li><a class="tocitem" href="#Tips"><span>Tips</span></a></li><li><a class="tocitem" href="#Comparison"><span>Comparison</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Coming from <em>PyCall</em>?</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Coming from <em>PyCall</em>?</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cjdoris/PythonCall.jl/blob/master/docs/src/pycall.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Coming-from-*PyCall*?"><a class="docs-heading-anchor" href="#Coming-from-*PyCall*?">Coming from <em>PyCall</em>?</a><a id="Coming-from-*PyCall*?-1"></a><a class="docs-heading-anchor-permalink" href="#Coming-from-*PyCall*?" title="Permalink"></a></h1><p>Another similar interface to Python is provided by <a href="https://github.com/JuliaPy/PyCall.jl"><code>PyCall</code></a>.</p><p>On this page, we give some tips for migrating between the two modules and a comparison.</p><h2 id="Tips"><a class="docs-heading-anchor" href="#Tips">Tips</a><a id="Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Tips" title="Permalink"></a></h2><ul><li>You can use both PyCall and PythonCall in the same Julia session (this might be platform dependent).</li><li>To force PythonCall to use the same Python interpreter as PyCall, set the environment variable <code>JULIA_PYTHONCALL_EXE</code> to <code>&quot;@PyCall&quot;</code>.</li></ul><h2 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h2><h3 id="Flexibility-of-conversion"><a class="docs-heading-anchor" href="#Flexibility-of-conversion">Flexibility of conversion</a><a id="Flexibility-of-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Flexibility-of-conversion" title="Permalink"></a></h3><p>In PyCall you do <code>convert(T, x)</code> to convert the Python object <code>x</code> to a Julia <code>T</code>. In PythonCall you similarly do <code>pyconvert(T, x)</code>.</p><p>PythonCall supports far more combinations of types of <code>T</code> and <code>x</code>. For example <code>convert(Vector, x)</code> in PyCall requires <code>x</code> to be a sequence, whereas in PythonCall <code>pyconvert(Vector, x)</code> works if <code>x</code> is an iterable, an object supporting the buffer protocol (such as <code>bytes</code>) or an object supporting the numpy array interface (such as <code>numpy.ndarray</code>).</p><p>Furthermore, <code>pyconvert</code> can be extended to support more types, whereas <code>convert(Vector, x)</code> cannot support more Python types.</p><h3 id="Lossiness-of-conversion"><a class="docs-heading-anchor" href="#Lossiness-of-conversion">Lossiness of conversion</a><a id="Lossiness-of-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Lossiness-of-conversion" title="Permalink"></a></h3><p>Both packages allow conversion of Julia values to Python: <code>PyObject(x)</code> in PyCall, <code>Py(x)</code> in PythonCall.</p><p>Whereas both packages convert numbers, booleans, tuples and strings to their Python counterparts, they differ in handling other types. For example PyCall converts <code>AbstractVector</code> to <code>list</code> whereas PythonCall converts <code>AbstractVector</code> to <code>juliacall.VectorValue</code> which is a sequence type directly wrapping the Julia value - this has the advantage that mutating the Python object also mutates the original Julia object.</p><p>Hence with PyCall the following does not mutate the original array <code>x</code>:</p><pre><code class="language-julia hljs">x = [&quot;foo&quot;, &quot;bar&quot;]
PyObject(x).append(&quot;baz&quot;)
@show x # --&gt; [&quot;foo&quot;, &quot;bar&quot;]</code></pre><p>whereas with PythonCall the following does mutate <code>x</code>:</p><pre><code class="language-julia hljs">x = [&quot;foo&quot;, &quot;bar&quot;]
Py(x).append(&quot;baz&quot;)
@show x # --&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</code></pre><p>In fact, PythonCall has the policy that any mutable object will by default be wrapped in this way, which not only preserves mutability but makes conversion faster for large containers since it does not require taking a copy of all the data.</p><h3 id="Automatic-conversion"><a class="docs-heading-anchor" href="#Automatic-conversion">Automatic conversion</a><a id="Automatic-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-conversion" title="Permalink"></a></h3><p>In PyCall, most function calls, attribute accesses, indexing, etc. of Python object by default automatically convert their result to a Julia object. This means that the following</p><pre><code class="language-julia hljs">pyimport(&quot;sys&quot;).modules[&quot;KEY&quot;] = &quot;VALUE&quot;</code></pre><p>does not actually modify the modules dict because it was <em>copied</em> to a new Julia <code>Dict</code>. This was probably not intended, plus it wasted time copying the whole dictionary. Instead you must do</p><pre><code class="language-julia hljs">set!(pyimport(os).&quot;environ&quot;, &quot;KEY&quot;, &quot;VALUE&quot;)</code></pre><p>In PythonCall, we don&#39;t do any such automatic conversion: we always return <code>Py</code>. This means that the first piece of code above does what you think.</p><h3 id="Which-Python"><a class="docs-heading-anchor" href="#Which-Python">Which Python</a><a id="Which-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Which-Python" title="Permalink"></a></h3><p>PyCall uses some global installation of Python - typically the version of Python installed on the system or used by Conda.</p><p>PythonCall uses a separate Conda environment for each Julia environment/project/package and installs Python (and other Python packages) into that. This means that different Julia projects can maintain an isolated set of Python dependencies (including the Python version itself).</p><h3 id="Corresponding-Python-packages"><a class="docs-heading-anchor" href="#Corresponding-Python-packages">Corresponding Python packages</a><a id="Corresponding-Python-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Corresponding-Python-packages" title="Permalink"></a></h3><p>PyCall has the corresponding Python package <a href="https://github.com/JuliaPy/pyjulia">pyjulia</a> for calling Julia from Python, and PythonCall similarly has juliacall.</p><p>One difference is between them is their code size: pyjulia is a large package, whereas juliacall is very small, with most of the implementation being in PythonCall itself. The practical up-shot is that PythonCall/juliacall have very symmetric interfaces; for example they use identical conversion policies and have the same set of wrapper types available.</p><p>Note also that juliacall will use a separate Julia project for each virtual/conda environment. This means that different Python environments can maintain an isolated set of Julia dependencies, including the versions of Julia and PythonCall themselves.</p><h3 id="Compatability"><a class="docs-heading-anchor" href="#Compatability">Compatability</a><a id="Compatability-1"></a><a class="docs-heading-anchor-permalink" href="#Compatability" title="Permalink"></a></h3><p>PyCall supports Julia 0.7+ and Python 2.7+, whereas PythonCall supports Julia 1.0+ and Python 3.5+. PyCall requires numpy to be installed, PythonCall doesn&#39;t (it provides the same fast array access through the buffer protocol and array interface).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compat/">« Compatibility Tools</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 21 October 2021 18:07">Thursday 21 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
