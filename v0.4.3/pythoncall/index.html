<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Julia module PythonCall · PythonCall &amp; JuliaCall</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PythonCall &amp; JuliaCall logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PythonCall &amp; JuliaCall</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>The Julia module PythonCall</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Py"><span><code>Py</code></span></a></li><li><a class="tocitem" href="#@py"><span><code>@py</code></span></a></li><li><a class="tocitem" href="#Python-functions"><span>Python functions</span></a></li><li><a class="tocitem" href="#python-deps"><span>Managing Python dependencies</span></a></li><li><a class="tocitem" href="#Writing-packages-which-depend-on-PythonCall"><span>Writing packages which depend on PythonCall</span></a></li><li><a class="tocitem" href="#Low-level-API"><span>Low-level API</span></a></li></ul></li><li><a class="tocitem" href="../juliacall/">The Python module JuliaCall</a></li><li><a class="tocitem" href="../conversion-to-python/">Conversion to Python</a></li><li><a class="tocitem" href="../conversion-to-julia/">Conversion to Julia</a></li><li><a class="tocitem" href="../compat/">Compatibility Tools</a></li><li><a class="tocitem" href="../pycall/">Coming from <em>PyCall</em>?</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Julia module PythonCall</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Julia module PythonCall</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cjdoris/PythonCall.jl/blob/master/docs/src/pythoncall.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Julia-module-PythonCall"><a class="docs-heading-anchor" href="#The-Julia-module-PythonCall">The Julia module PythonCall</a><a id="The-Julia-module-PythonCall-1"></a><a class="docs-heading-anchor-permalink" href="#The-Julia-module-PythonCall" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This package is in the general registry, so to install just type <code>]</code> in the Julia REPL and run:</p><pre><code class="language-julia-repl hljs">pkg&gt; add PythonCall</code></pre><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>Import the module with:</p><pre><code class="language-julia-repl hljs">julia&gt; using PythonCall</code></pre><p>By default this will initialize a conda environment in your Julia environment, install Python into it, load the corresponding Python library and initialize an interpreter.</p><p>Now you can interact with Python as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; re = pyimport(&quot;re&quot;)
Python module: &lt;module &#39;re&#39; from &#39;[...]/lib/re.py&#39;&gt;

julia&gt; words = re.findall(&quot;[a-zA-Z]+&quot;, &quot;PythonCall.jl is very useful!&quot;)
Python list: [&#39;PythonCall&#39;, &#39;jl&#39;, &#39;is&#39;, &#39;very&#39;, &#39;useful&#39;]

julia&gt; sentence = Py(&quot; &quot;).join(words)
Python str: &#39;PythonCall jl is very useful&#39;

julia&gt; pyconvert(String, sentence)
&quot;PythonCall jl is very useful&quot;</code></pre><p>In this example:</p><ul><li>We used <a href="#PythonCall.pyimport"><code>pyimport</code></a> to import the <code>re</code> module. Equivalently we could have done <code>@py import re</code> (see <a href="#PythonCall.@py"><code>@py</code></a>).</li><li>We called its <code>findall</code> function on a pair of strings, which were automatically converted to Python strings (see <a href="../conversion-to-python/#jl2py">Conversion to Python</a>).</li><li>We called <a href="#PythonCall.Py"><code>Py</code></a> to explicitly convert a string to a Python string, so that we could call its <code>join</code> method. All Python objects are of type <code>Py</code>.</li><li>We called <a href="#PythonCall.pyconvert"><code>pyconvert</code></a> to convert the Python string <code>sentence</code> to a Julia string (see <a href="../conversion-to-julia/#py2jl">Conversion to Julia</a>).</li></ul><p>What to read next:</p><ul><li>The rest of this page details the functions for interacting with Python objects, of type <a href="#PythonCall.Py"><code>Py</code></a>.</li><li>If you need to install Python packages, <a href="#python-deps">read here</a>.</li><li>When you call a Python function, such as <code>re.findall(...)</code> in the above example, its arguments are converted to Python according to <a href="../conversion-to-python/#jl2py-conversion">this table</a> and its return value is a <a href="#PythonCall.Py"><code>Py</code></a>.</li><li>Python objects can be converted to Julia objects using <a href="#PythonCall.pyconvert"><code>pyconvert</code></a> with rules according to <a href="../conversion-to-julia/#py2jl-conversion">this table</a>.</li><li>Python objects can also be wrapped to provide more Julian semantics. For example, a <a href="../conversion-to-julia/#PythonCall.PyDict"><code>PyDict</code></a> wraps a Python dict as a Julia dict, and a <a href="../conversion-to-julia/#PythonCall.PyArray"><code>PyArray</code></a> wraps a Python array or buffer as a Julia array. <a href="@id python-wrappers">See here</a>.</li></ul><h2 id="Py"><a class="docs-heading-anchor" href="#Py"><code>Py</code></a><a id="Py-1"></a><a class="docs-heading-anchor-permalink" href="#Py" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PythonCall.Py" href="#PythonCall.Py"><code>PythonCall.Py</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Py(x)</code></pre><p>Convert <code>x</code> to a Python object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/Py.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.@pyconst" href="#PythonCall.@pyconst"><code>PythonCall.@pyconst</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@pyconst ex</code></pre><p>Equivalent to <code>Py(ex)</code> but always returns the exact same Julia object.</p><p>That is, if <code>foo() = @pyconst ex</code> then <code>foo() === foo()</code>.</p><p>The expression <code>ex</code> is evaluated the first time the code is run.</p><p>If <code>ex</code> is a string literal, the string is interned.</p><p>Do not use this macro at the top level of a module. Instead, use <code>pynew()</code> and <code>pycopy!()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/pyconst_macro.jl#L1-L13">source</a></section></article><p>The object <code>pybuiltins</code> has all the standard Python builtin objects as its properties. Hence you can access <code>pybuiltins.None</code> and <code>pybuiltins.TypeError</code>.</p><h2 id="@py"><a class="docs-heading-anchor" href="#@py"><code>@py</code></a><a id="@py-1"></a><a class="docs-heading-anchor-permalink" href="#@py" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PythonCall.@py" href="#PythonCall.@py"><code>PythonCall.@py</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@py expr</code></pre><p>Evaluate the given expression using Pythonic semantics.</p><p>For example:</p><ul><li><code>f(x, y)</code> is translated to <code>pycall(f, x, y)</code></li><li><code>x + y</code> is translated to <code>pyadd(x, y)</code></li><li><code>x === y</code> is translated to <code>pyis(x, y)</code></li><li><code>x.foo</code> is translated to <code>pygetattr(x, &quot;foo&quot;)</code></li></ul><p>Compound statements such as <code>begin</code>, <code>if</code>, <code>while</code> and <code>for</code> are supported.</p><p>See the online documentation for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/py_macro.jl#L784-L798">source</a></section></article><h2 id="Python-functions"><a class="docs-heading-anchor" href="#Python-functions">Python functions</a><a id="Python-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Python-functions" title="Permalink"></a></h2><p>Most of the functions in this section are essentially Python builtins with a <code>py</code> prefix. For example <code>pyint(x)</code> converts <code>x</code> to a Python <code>int</code> and is equivalent to <code>int(x)</code> in Python when <code>x</code> is a Python object.</p><p>Notable exceptions are:</p><ul><li><a href="#PythonCall.pyconvert"><code>pyconvert</code></a> to convert a Python object to a Julia object.</li><li><a href="#PythonCall.pyimport"><code>pyimport</code></a> to import a Python module.</li><li><a href="#PythonCall.pyjl"><code>pyjl</code></a> to directly wrap a Julia object as a Python object.</li><li><a href="#PythonCall.pyclass"><code>pyclass</code></a> to construct a new class.</li><li><a href="#PythonCall.pywith"><code>pywith</code></a> to emulate the Python <code>with</code> statement.</li></ul><p>If a Julia value is passed as an argument to one of these functions, it is converted to a Python value using the rules documented <a href="../conversion-to-python/#jl2py">here</a>.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>These functions construct Python objects of builtin types from Julia values.</p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pybool" href="#PythonCall.pybool"><code>PythonCall.pybool</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pybool(x)</code></pre><p>Convert <code>x</code> to a Python <code>bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/bool.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyint" href="#PythonCall.pyint"><code>PythonCall.pyint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyint(x=0)</code></pre><p>Convert <code>x</code> to a Python <code>int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/int.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyfloat" href="#PythonCall.pyfloat"><code>PythonCall.pyfloat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyfloat(x=0.0)</code></pre><p>Convert <code>x</code> to a Python <code>float</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/float.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pycomplex" href="#PythonCall.pycomplex"><code>PythonCall.pycomplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pycomplex(x=0.0)
pycomplex(re, im)</code></pre><p>Convert <code>x</code> to a Python <code>complex</code>, or create one from given real and imaginary parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/complex.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pystr" href="#PythonCall.pystr"><code>PythonCall.pystr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pystr(x)</code></pre><p>Convert <code>x</code> to a Python <code>str</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/str.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pybytes" href="#PythonCall.pybytes"><code>PythonCall.pybytes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pybytes(x)</code></pre><p>Convert <code>x</code> to a Python <code>bytes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/bytes.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pytuple" href="#PythonCall.pytuple"><code>PythonCall.pytuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pytuple(x=())</code></pre><p>Convert <code>x</code> to a Python <code>tuple</code>.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>tuple(x)</code> in Python. Otherwise <code>x</code> must be iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/tuple.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pylist" href="#PythonCall.pylist"><code>PythonCall.pylist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pylist(x=())</code></pre><p>Convert <code>x</code> to a Python <code>list</code>.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>list(x)</code> in Python. Otherwise <code>x</code> must be iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/list.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pycollist" href="#PythonCall.pycollist"><code>PythonCall.pycollist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pycollist(x::AbstractArray)</code></pre><p>Create a nested Python <code>list</code>-of-<code>list</code>s from the elements of <code>x</code>. For matrices, this is a list of columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/list.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyrowlist" href="#PythonCall.pyrowlist"><code>PythonCall.pyrowlist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyrowlist(x::AbstractArray)</code></pre><p>Create a nested Python <code>list</code>-of-<code>list</code>s from the elements of <code>x</code>. For matrices, this is a list of rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/list.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyset" href="#PythonCall.pyset"><code>PythonCall.pyset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyset(x=())</code></pre><p>Convert <code>x</code> to a Python <code>set</code>.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>set(x)</code> in Python. Otherwise <code>x</code> must be iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/set.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyfrozenset" href="#PythonCall.pyfrozenset"><code>PythonCall.pyfrozenset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyfrozenset(x=())</code></pre><p>Convert <code>x</code> to a Python <code>frozenset</code>.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>frozenset(x)</code> in Python. Otherwise <code>x</code> must be iterable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/set.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pydict" href="#PythonCall.pydict"><code>PythonCall.pydict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pydict(x)
pydict(; x...)</code></pre><p>Convert <code>x</code> to a Python <code>dict</code>. In the second form, the keys are strings.</p><p>If <code>x</code> is a Python object, this is equivalent to <code>dict(x)</code> in Python. Otherwise <code>x</code> must iterate over key-value pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/dict.jl#L19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyslice" href="#PythonCall.pyslice"><code>PythonCall.pyslice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyslice([start], stop, [step])</code></pre><p>Construct a Python <code>slice</code>. Unspecified arguments default to <code>None</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/slice.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyrange" href="#PythonCall.pyrange"><code>PythonCall.pyrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyrange([[start], [stop]], [step])</code></pre><p>Construct a Python <code>range</code>. Unspecified arguments default to <code>None</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/range.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pymethod" href="#PythonCall.pymethod"><code>PythonCall.pymethod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pymethod(x)</code></pre><p>Convert callable <code>x</code> to a Python instance method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/method.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pytype" href="#PythonCall.pytype"><code>PythonCall.pytype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pytype(x)</code></pre><p>The Python <code>type</code> of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/type.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyclass" href="#PythonCall.pyclass"><code>PythonCall.pyclass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyclass(name, bases=(); members...)</code></pre><p>Construct a new Python type with the given name, bases and members.</p><p>Equivalent to <code>pytype(name, bases, members)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/type.jl#L10-L16">source</a></section></article><h3 id="Builtins"><a class="docs-heading-anchor" href="#Builtins">Builtins</a><a id="Builtins-1"></a><a class="docs-heading-anchor-permalink" href="#Builtins" title="Permalink"></a></h3><p>These functions mimic the Python builtin functions or keywords of the same name.</p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyimport" href="#PythonCall.pyimport"><code>PythonCall.pyimport</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyimport(m)
pyimport(m =&gt; k)
pyimport(m =&gt; (k1, k2, ...))
pyimport(m1, m2, ...)</code></pre><p>Import a module <code>m</code>, or an attribute <code>k</code>, or a tuple of attributes.</p><p>If several arguments are given, return the results of importing each one in a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/concrete/import.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pywith" href="#PythonCall.pywith"><code>PythonCall.pywith</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pywith(f, o, d=nothing)</code></pre><p>Equivalent to <code>with o as x: f(x)</code> in Python, where <code>x</code> is a <code>Py</code>.</p><p>On success, the value of <code>f(x)</code> is returned.</p><p>If an exception occurs but is suppressed then <code>d</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/compat/with.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyis" href="#PythonCall.pyis"><code>PythonCall.pyis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyis(x, y)</code></pre><p>True if <code>x</code> and <code>y</code> are the same Python object. Equivalent to <code>x is y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyrepr" href="#PythonCall.pyrepr"><code>PythonCall.pyrepr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyrepr(x)</code></pre><p>Equivalent to <code>repr(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyascii" href="#PythonCall.pyascii"><code>PythonCall.pyascii</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyascii(x)</code></pre><p>Equivalent to <code>ascii(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyhasattr" href="#PythonCall.pyhasattr"><code>PythonCall.pyhasattr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyhasattr(x, k)</code></pre><p>Equivalent to <code>hasattr(x, k)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pygetattr" href="#PythonCall.pygetattr"><code>PythonCall.pygetattr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pygetattr(x, k, [d])</code></pre><p>Equivalent to <code>getattr(x, k)</code> or <code>x.k</code> in Python.</p><p>If <code>d</code> is specified, it is returned if the attribute does not exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pysetattr" href="#PythonCall.pysetattr"><code>PythonCall.pysetattr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pysetattr(x, k, v)</code></pre><p>Equivalent to <code>setattr(x, k, v)</code> or <code>x.k = v</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pydelattr" href="#PythonCall.pydelattr"><code>PythonCall.pydelattr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pydelattr(x, k)</code></pre><p>Equivalent to <code>delattr(x, k)</code> or <code>del x.k</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pydir" href="#PythonCall.pydir"><code>PythonCall.pydir</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pydir(x)</code></pre><p>Equivalent to <code>dir(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pycall" href="#PythonCall.pycall"><code>PythonCall.pycall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pycall(f, args...; kwargs...)</code></pre><p>Call the Python object <code>f</code> with the given arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pylen" href="#PythonCall.pylen"><code>PythonCall.pylen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pylen(x)</code></pre><p>The length of <code>x</code>. Equivalent to <code>len(x)</code> in Python, converted to an <code>Integer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pycontains" href="#PythonCall.pycontains"><code>PythonCall.pycontains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pycontains(x, v)</code></pre><p>Equivalent to <code>v in x</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyin" href="#PythonCall.pyin"><code>PythonCall.pyin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyin(v, x)</code></pre><p>Equivalent to <code>v in x</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pygetitem" href="#PythonCall.pygetitem"><code>PythonCall.pygetitem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pygetitem(x, k)</code></pre><p>Equivalent to <code>getitem(x, k)</code> or <code>x[k]</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pysetitem" href="#PythonCall.pysetitem"><code>PythonCall.pysetitem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pysetitem(x, k, v)</code></pre><p>Equivalent to <code>setitem(x, k, v)</code> or <code>x[k] = v</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pydelitem" href="#PythonCall.pydelitem"><code>PythonCall.pydelitem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pydelitem(x, k)</code></pre><p>Equivalent to <code>delitem(x, k)</code> or <code>del x[k]</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyissubclass" href="#PythonCall.pyissubclass"><code>PythonCall.pyissubclass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyissubclass(s, t)</code></pre><p>Test if <code>s</code> is a subclass of <code>t</code>. Equivalent to <code>issubclass(s, t)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyisinstance" href="#PythonCall.pyisinstance"><code>PythonCall.pyisinstance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyisinstance(x, t)</code></pre><p>Test if <code>x</code> is of type <code>t</code>. Equivalent to <code>isinstance(x, t)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyhash" href="#PythonCall.pyhash"><code>PythonCall.pyhash</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyhash(x)</code></pre><p>Equivalent to <code>hash(x)</code> in Python, converted to an <code>Integer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyiter" href="#PythonCall.pyiter"><code>PythonCall.pyiter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyiter(x)</code></pre><p>Equivalent to <code>iter(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/iter.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pynext" href="#PythonCall.pynext"><code>PythonCall.pynext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pynext(x)</code></pre><p>Equivalent to <code>next(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/iter.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyhelp" href="#PythonCall.pyhelp"><code>PythonCall.pyhelp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyhelp([x])</code></pre><p>Equivalent to <code>help(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/builtins.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyprint" href="#PythonCall.pyprint"><code>PythonCall.pyprint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyprint(...)</code></pre><p>Equivalent to <code>print(...)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/builtins.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyall" href="#PythonCall.pyall"><code>PythonCall.pyall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyall(x)</code></pre><p>Equivalent to <code>all(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/builtins.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyany" href="#PythonCall.pyany"><code>PythonCall.pyany</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyany(x)</code></pre><p>Equivalent to <code>any(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/builtins.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pycallable" href="#PythonCall.pycallable"><code>PythonCall.pycallable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pycallable(x)</code></pre><p>Equivalent to <code>callable(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/builtins.jl#L46-L50">source</a></section></article><h3 id="Conversion-to-Julia"><a class="docs-heading-anchor" href="#Conversion-to-Julia">Conversion to Julia</a><a id="Conversion-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-to-Julia" title="Permalink"></a></h3><p>These functions convert Python values to Julia values, using the rules documented <a href="../conversion-to-python/#jl2py">here</a>.</p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyconvert" href="#PythonCall.pyconvert"><code>PythonCall.pyconvert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyconvert(T, x, [d])</code></pre><p>Convert the Python object <code>x</code> to a <code>T</code>.</p><p>If <code>d</code> is specified, it is returned on failure instead of throwing an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/convert.jl#L263-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.@pyconvert" href="#PythonCall.@pyconvert"><code>PythonCall.@pyconvert</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@pyconvert(T, x, [onfail])</code></pre><p>Convert the Python object <code>x</code> to a <code>T</code>.</p><p>On failure, evaluates to <code>onfail</code>, which defaults to <code>return pyconvert_unconverted()</code> (mainly useful for writing conversion rules).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/convert.jl#L244-L250">source</a></section></article><h3 id="Wrap-Julia-values"><a class="docs-heading-anchor" href="#Wrap-Julia-values">Wrap Julia values</a><a id="Wrap-Julia-values-1"></a><a class="docs-heading-anchor-permalink" href="#Wrap-Julia-values" title="Permalink"></a></h3><p>These functions explicitly wrap Julia values into Python objects, documented <a href="../conversion-to-python/#julia-wrappers">here</a>.</p><p>As documented <a href="../conversion-to-julia/#py2jl">here</a>, Julia values are wrapped like this automatically on conversion to Python, unless the value is immutable and has a corresponding Python type.</p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyjl" href="#PythonCall.pyjl"><code>PythonCall.pyjl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyjl([t], x)</code></pre><p>Create a Python object wrapping the Julia object <code>x</code>.</p><p>If <code>x</code> is mutable, then mutating the returned object also mutates <code>x</code>, and vice versa.</p><p>Its Python type is normally inferred from the type of <code>x</code>, but can be specified with <code>t</code>.</p><p>For example if <code>x</code> is an <code>AbstractVector</code> then the object will have type <code>juliacall.VectorValue</code>. This object will satisfy the Python sequence interface, so for example uses 0-up indexing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/jlwrap/any.jl#L303-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyjlraw" href="#PythonCall.pyjlraw"><code>PythonCall.pyjlraw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyjlraw(v)</code></pre><p>Create a Python object wrapping the Julia object <code>x</code>.</p><p>It has type <code>juliacall.RawValue</code>. This has a much more rigid &quot;Julian&quot; interface than <code>pyjl(v)</code>. For example, accessing attributes or calling this object will always return a <code>RawValue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/jlwrap/raw.jl#L126-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyisjl" href="#PythonCall.pyisjl"><code>PythonCall.pyisjl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyisjl(x)</code></pre><p>Test whether <code>x</code> is a wrapped Julia value, namely an instance of <code>juliacall.ValueBase</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/jlwrap/base.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyjlvalue" href="#PythonCall.pyjlvalue"><code>PythonCall.pyjlvalue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyjlvalue(x)</code></pre><p>Extract the value from the wrapped Julia value <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/jlwrap/base.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pytextio" href="#PythonCall.pytextio"><code>PythonCall.pytextio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pytextio(io::IO)</code></pre><p>Wrap <code>io</code> as a Python text IO object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/jlwrap/io.jl#L317-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pybinaryio" href="#PythonCall.pybinaryio"><code>PythonCall.pybinaryio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pybinaryio(io::IO)</code></pre><p>Wrap <code>io</code> as a Python binary IO object.</p><p>This is the default behaviour of <code>Py(io)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/jlwrap/io.jl#L307-L313">source</a></section></article><h3 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h3><p>These functions are equivalent to the corresponding Python arithmetic operators.</p><p>Note that the equivalent Julia operators are overloaded to call these when all arguments are <code>Py</code> (or <code>Number</code>). Hence the following are equivalent: <code>Py(1)+Py(2)</code>, <code>Py(1)+2</code>, <code>pyadd(1, 2)</code>, <code>pyadd(Py(1), Py(2))</code>, etc.</p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyneg" href="#PythonCall.pyneg"><code>PythonCall.pyneg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyneg(x)</code></pre><p>Equivalent to <code>-x</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pypos" href="#PythonCall.pypos"><code>PythonCall.pypos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pypos(x)</code></pre><p>Equivalent to <code>+x</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyabs" href="#PythonCall.pyabs"><code>PythonCall.pyabs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyabs(x)</code></pre><p>Equivalent to <code>abs(x)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyinv" href="#PythonCall.pyinv"><code>PythonCall.pyinv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyinv(x)</code></pre><p>Equivalent to <code>~x</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyindex" href="#PythonCall.pyindex"><code>PythonCall.pyindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyindex(x)</code></pre><p>Convert <code>x</code> losslessly to an <code>int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyadd" href="#PythonCall.pyadd"><code>PythonCall.pyadd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyadd(x, y)</code></pre><p>Equivalent to <code>x + y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pysub" href="#PythonCall.pysub"><code>PythonCall.pysub</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pysub(x, y)</code></pre><p>Equivalent to <code>x - y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pymul" href="#PythonCall.pymul"><code>PythonCall.pymul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pymul(x, y)</code></pre><p>Equivalent to <code>x * y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pymatmul" href="#PythonCall.pymatmul"><code>PythonCall.pymatmul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pymatmul(x, y)</code></pre><p>Equivalent to <code>x @ y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pypow" href="#PythonCall.pypow"><code>PythonCall.pypow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pypow(x, y, z=None)</code></pre><p>Equivalent to <code>x ** y</code> or <code>pow(x, y, z)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyfloordiv" href="#PythonCall.pyfloordiv"><code>PythonCall.pyfloordiv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyfloordiv(x, y)</code></pre><p>Equivalent to <code>x // y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pytruediv" href="#PythonCall.pytruediv"><code>PythonCall.pytruediv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pytruediv(x, y)</code></pre><p>Equivalent to <code>x / y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pymod" href="#PythonCall.pymod"><code>PythonCall.pymod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pymod(x, y)</code></pre><p>Equivalent to <code>x % y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pydivmod" href="#PythonCall.pydivmod"><code>PythonCall.pydivmod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pydivmod(x, y)</code></pre><p>Equivalent to <code>divmod(x, y)</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pylshift" href="#PythonCall.pylshift"><code>PythonCall.pylshift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pylshift(x, y)</code></pre><p>Equivalent to <code>x &lt;&lt; y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyrshift" href="#PythonCall.pyrshift"><code>PythonCall.pyrshift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyrshift(x, y)</code></pre><p>Equivalent to <code>x &gt;&gt; y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyand" href="#PythonCall.pyand"><code>PythonCall.pyand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyand(x, y)</code></pre><p>Equivalent to <code>x &amp; y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyxor" href="#PythonCall.pyxor"><code>PythonCall.pyxor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyxor(x, y)</code></pre><p>Equivalent to <code>x ^ y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyor" href="#PythonCall.pyor"><code>PythonCall.pyor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyor(x, y)</code></pre><p>Equivalent to <code>x | y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyiadd" href="#PythonCall.pyiadd"><code>PythonCall.pyiadd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyiadd(x, y)</code></pre><p>In-place add. <code>x = pyiadd(x, y)</code> is equivalent to <code>x += y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyisub" href="#PythonCall.pyisub"><code>PythonCall.pyisub</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyisub(x, y)</code></pre><p>In-place subtract. <code>x = pyisub(x, y)</code> is equivalent to <code>x -= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyimul" href="#PythonCall.pyimul"><code>PythonCall.pyimul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyimul(x, y)</code></pre><p>In-place multiply. <code>x = pyimul(x, y)</code> is equivalent to <code>x *= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyimatmul" href="#PythonCall.pyimatmul"><code>PythonCall.pyimatmul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyimatmul(x, y)</code></pre><p>In-place matrix multiply. <code>x = pyimatmul(x, y)</code> is equivalent to <code>x @= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyipow" href="#PythonCall.pyipow"><code>PythonCall.pyipow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyipow(x, y, z=None)</code></pre><p>In-place power. <code>x = pyipow(x, y)</code> is equivalent to <code>x **= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyifloordiv" href="#PythonCall.pyifloordiv"><code>PythonCall.pyifloordiv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyifloordiv(x, y)</code></pre><p>In-place floor divide. <code>x = pyifloordiv(x, y)</code> is equivalent to <code>x //= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyitruediv" href="#PythonCall.pyitruediv"><code>PythonCall.pyitruediv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyitruediv(x, y)</code></pre><p>In-place true division. <code>x = pyitruediv(x, y)</code> is equivalent to <code>x /= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyimod" href="#PythonCall.pyimod"><code>PythonCall.pyimod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyimod(x, y)</code></pre><p>In-place subtraction. <code>x = pyimod(x, y)</code> is equivalent to <code>x %= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyilshift" href="#PythonCall.pyilshift"><code>PythonCall.pyilshift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyilshift(x, y)</code></pre><p>In-place left shift. <code>x = pyilshift(x, y)</code> is equivalent to <code>x &lt;&lt;= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyirshift" href="#PythonCall.pyirshift"><code>PythonCall.pyirshift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyirshift(x, y)</code></pre><p>In-place right shift. <code>x = pyirshift(x, y)</code> is equivalent to <code>x &gt;&gt;= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyiand" href="#PythonCall.pyiand"><code>PythonCall.pyiand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyiand(x, y)</code></pre><p>In-place and. <code>x = pyiand(x, y)</code> is equivalent to <code>x &amp;= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyixor" href="#PythonCall.pyixor"><code>PythonCall.pyixor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyixor(x, y)</code></pre><p>In-place xor. <code>x = pyixor(x, y)</code> is equivalent to <code>x ^= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyior" href="#PythonCall.pyior"><code>PythonCall.pyior</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyior(x, y)</code></pre><p>In-place or. <code>x = pyior(x, y)</code> is equivalent to <code>x |= y</code> in Python.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/number.jl#L182-L186">source</a></section></article><h3 id="Logic"><a class="docs-heading-anchor" href="#Logic">Logic</a><a id="Logic-1"></a><a class="docs-heading-anchor-permalink" href="#Logic" title="Permalink"></a></h3><p>These functions are equivalent to the corresponding Python logical operators.</p><p>Note that the equivalent Julia operators are overloaded to call these when all arguments are <code>Py</code> (or <code>Number</code>). Hence the following are equivalent: <code>Py(1) &lt; Py(2)</code>, <code>Py(1) &lt; 2</code>, <code>pylt(1, 2)</code>, <code>pylt(Py(1), Py(2))</code>, etc.</p><p>Note that the binary operators by default return <code>Py</code> (not <code>Bool</code>) since comparisons in Python do not necessarily return <code>bool</code>.</p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pytruth" href="#PythonCall.pytruth"><code>PythonCall.pytruth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pytruth(x)</code></pre><p>The truthyness of <code>x</code>. Equivalent to <code>bool(x)</code> in Python, converted to a <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pynot" href="#PythonCall.pynot"><code>PythonCall.pynot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pynot(x)</code></pre><p>The falsyness of <code>x</code>. Equivalent to <code>not x</code> in Python, converted to a <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyeq" href="#PythonCall.pyeq"><code>PythonCall.pyeq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyeq(x, y)
pyeq(Bool, x, y)</code></pre><p>Equivalent to <code>x == y</code> in Python. The second form converts to <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyne" href="#PythonCall.pyne"><code>PythonCall.pyne</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyne(x, y)
pyne(Bool, x, y)</code></pre><p>Equivalent to <code>x != y</code> in Python. The second form converts to <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyle" href="#PythonCall.pyle"><code>PythonCall.pyle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyle(x, y)
pyle(Bool, x, y)</code></pre><p>Equivalent to <code>x &lt;= y</code> in Python. The second form converts to <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pylt" href="#PythonCall.pylt"><code>PythonCall.pylt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pylt(x, y)
pylt(Bool, x, y)</code></pre><p>Equivalent to <code>x &lt; y</code> in Python. The second form converts to <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyge" href="#PythonCall.pyge"><code>PythonCall.pyge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyge(x, y)
pyge(Bool, x, y)</code></pre><p>Equivalent to <code>x &gt;= y</code> in Python. The second form converts to <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L207-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pygt" href="#PythonCall.pygt"><code>PythonCall.pygt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pygt(x, y)
pygt(Bool, x, y)</code></pre><p>Equivalent to <code>x &gt; y</code> in Python. The second form converts to <code>Bool</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/object.jl#L214-L219">source</a></section></article><h2 id="python-deps"><a class="docs-heading-anchor" href="#python-deps">Managing Python dependencies</a><a id="python-deps-1"></a><a class="docs-heading-anchor-permalink" href="#python-deps" title="Permalink"></a></h2><p>PythonCall manages its Python dependencies using Conda. A Conda environment is automatically created in your active Julia environment when PythonCall is loaded, is initialised with at least <code>python</code> and <code>pip</code>, and is activated.</p><p>If your project requires more Python dependencies, use the mechanisms below to ensure they are automatically installed.</p><p><strong>Do not install packages using conda or pip directly!</strong> PythonCall can and will delete and reinstall its Conda environment periodically, such as when any dependencies change.</p><p><strong>We strongly recommend that you specify Conda dependencies</strong> if possible, instead of pip or script dependencies. This is because Conda can account for all inter-dependencies between packages and so prevent incompatible combinations of packages from being installed.</p><h3 id="PythonCallDeps.toml"><a class="docs-heading-anchor" href="#PythonCallDeps.toml">PythonCallDeps.toml</a><a id="PythonCallDeps.toml-1"></a><a class="docs-heading-anchor-permalink" href="#PythonCallDeps.toml" title="Permalink"></a></h3><p>If you put a file called <code>PythonCallDeps.toml</code> in a project/package/environment which depends on PythonCall, then the dependencies therein will be automatically installed into the Conda environment.</p><p>Here is an example (all parts are optional):</p><pre><code class="language-toml hljs">[conda]
packages = [&quot;python&gt;=3.6&quot;, &quot;scikit-learn&quot;]
channels = [&quot;conda-forge&quot;]

[pip]
packages = [&quot;numpy&gt;=1.21&quot;]
# indexes = [...]

[script]
# expr = &quot;some_julia_expression()&quot;
# file = &quot;/path/to/julia/script.jl&quot;</code></pre><p>When PythonCall starts, it will ensure the Conda environment has the given Conda and pip packages installed, and will run the script if specified.</p><h3 id="The-Deps-submodule"><a class="docs-heading-anchor" href="#The-Deps-submodule">The Deps submodule</a><a id="The-Deps-submodule-1"></a><a class="docs-heading-anchor-permalink" href="#The-Deps-submodule" title="Permalink"></a></h3><p>Instead of manually editing <code>PythonCallDeps.toml</code>, you can use the submodule <code>PythonCall.Deps</code> to manage the Python dependencies of the current Julia project.</p><p>These functions are for interactive use, <strong>do not call them from packages!</strong></p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.Deps.status" href="#PythonCall.Deps.status"><code>PythonCall.Deps.status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">status()</code></pre><p>Display the status of dependencies of the current Julia project.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/deps.jl#L416-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.Deps.add" href="#PythonCall.Deps.add"><code>PythonCall.Deps.add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add(...)</code></pre><p>Add Python dependencies to the current Julia project.</p><p>Keyword arguments (all optional):</p><ul><li><code>conda_channels</code>: An iterable of conda channels to use.</li><li><code>conda_packages</code>: An iterable of conda packages to install.</li><li><code>pip_indexes</code>: An iterable of pip indexes to use.</li><li><code>pip_packages</code>: An iterable of pip packages to install.</li><li><code>script_expr</code>: An expression to evaluate in the <code>Deps</code> module.</li><li><code>script_file</code>: The path to a Julia file to evaluate in the <code>Deps</code> module.</li><li><code>resolve=true</code>: When true, immediately resolve the dependencies. Otherwise, the dependencies are not resolved until you call <a href="#PythonCall.Deps.resolve"><code>resolve</code></a> or load PythonCall in a new Julia session.</li><li><code>create=false</code>: When true, creates the environment from scratch when resolving.</li></ul><p>The conda and pip packages can include version specifiers, such as <code>python&gt;=3.6</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/deps.jl#L493-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.Deps.rm" href="#PythonCall.Deps.rm"><code>PythonCall.Deps.rm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rm(...)</code></pre><p>Remove Python dependencies from the current Julia project.</p><p>Keyword arguments (all optional):</p><ul><li><code>conda_channels</code>: An iterable of conda channels to remove.</li><li><code>conda_packages</code>: An iterable of conda packages to remove.</li><li><code>pip_indexes</code>: An iterable of pip indexes to remove.</li><li><code>pip_packages</code>: An iterable of pip packages to remove.</li><li><code>script_expr=false</code>: When true, remove the script expression.</li><li><code>script_file=false</code>: When true, remove the script file.</li><li><code>resolve=true</code>: When true, immediately resolve the dependencies. Otherwise, the dependencies are not resolved until you call <a href="#PythonCall.Deps.resolve"><code>resolve</code></a> or load PythonCall in a new Julia session.</li><li><code>create=true</code>: When true, creates the environment from scratch when resolving.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/deps.jl#L541-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.Deps.resolve" href="#PythonCall.Deps.resolve"><code>PythonCall.Deps.resolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resolve(; create=true, force=false)</code></pre><p>Resolve all Python dependencies.</p><p>If <code>create=true</code> then a new Conda environment is created and activated. Otherwise, the existing one is updated.</p><p>By default, if no dependencies have actually changed, then resolving them is skipped. Specify <code>force=true</code> to skip this check and force resolving dependencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/deps.jl#L270-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.Deps.conda_env" href="#PythonCall.Deps.conda_env"><code>PythonCall.Deps.conda_env</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conda_env()</code></pre><p>The path to the Conda environment in which Python dependencies are managed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/deps.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.Deps.user_deps_file" href="#PythonCall.Deps.user_deps_file"><code>PythonCall.Deps.user_deps_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">user_deps_file()</code></pre><p>The path to the <code>PythonCallDeps.toml</code> file in the active environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/deps.jl#L230-L234">source</a></section></article><h3 id="The-Python-interpreter"><a class="docs-heading-anchor" href="#The-Python-interpreter">The Python interpreter</a><a id="The-Python-interpreter-1"></a><a class="docs-heading-anchor-permalink" href="#The-Python-interpreter" title="Permalink"></a></h3><p>By default, <code>python</code> is automatically installed into the Conda environment mentioned above.</p><p>To use a different interpreter, you can set the environment variable <code>JULIA_PYTHONCALL_EXE</code> to its path before importing PythonCall. You can set it to <code>python</code> if it is in your PATH.</p><p>You can also set it to the special value <code>&quot;@PyCall&quot;</code> which will use the same interpreter as PyCall.</p><p>Note that using a non-default interpreter will disable all dependency management: no Conda environment will be created and no packages will be automatically installed. It is up to the user to ensure any required packages are installed.</p><h2 id="Writing-packages-which-depend-on-PythonCall"><a class="docs-heading-anchor" href="#Writing-packages-which-depend-on-PythonCall">Writing packages which depend on PythonCall</a><a id="Writing-packages-which-depend-on-PythonCall-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-packages-which-depend-on-PythonCall" title="Permalink"></a></h2><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>See [https://github.com/cjdoris/Faiss.jl] for an example package which wraps the Python FAISS package.</p><h3 id="Precompilation"><a class="docs-heading-anchor" href="#Precompilation">Precompilation</a><a id="Precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#Precompilation" title="Permalink"></a></h3><p>You may not interact with Python during module precompilation. Therefore, instead of</p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  const foo = pyimport(&quot;foo&quot;)
  bar() = foo.bar() # will crash when called
end</code></pre><p>you must do</p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  const foo = PythonCall.pynew() # initially NULL
  function __init__()
    PythonCall.pycopy!(foo, pyimport(&quot;foo&quot;))
  end
  bar() = foo.bar() # now ok
end</code></pre><h3 id="Dependencies"><a class="docs-heading-anchor" href="#Dependencies">Dependencies</a><a id="Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Dependencies" title="Permalink"></a></h3><p>If your package depends on some Python packages, you must write a <code>PythonCallDeps.toml</code> file. See <a href="@ref">Managing Python dependencies</a>.</p><h2 id="Low-level-API"><a class="docs-heading-anchor" href="#Low-level-API">Low-level API</a><a id="Low-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-API" title="Permalink"></a></h2><p>The functions here are not exported. They are mostly unsafe in the sense that you can crash Julia by using them incorrectly.</p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pynew" href="#PythonCall.pynew"><code>PythonCall.pynew</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pynew([ptr])</code></pre><p>A new <code>Py</code> representing the Python object at <code>ptr</code> (NULL by default).</p><p>If <code>ptr</code> is given and non-NULL, this function steals a reference to the Python object it points at, i.e. the new <code>Py</code> object owns a reference.</p><p>Note that NULL Python objects are not safe in the sense that most API functions will probably crash your Julia session if you pass a NULL argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/Py.jl#L55-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyisnull" href="#PythonCall.pyisnull"><code>PythonCall.pyisnull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyisnull(x)</code></pre><p>True if the Python object <code>x</code> is NULL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/Py.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pycopy!" href="#PythonCall.pycopy!"><code>PythonCall.pycopy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pycopy!(dst::Py, src)</code></pre><p>Copy the Python object <code>src</code> into <code>dst</code>, so that they both represent the same object.</p><p>This function exists to support module-level constant Python objects. It is illegal to call most PythonCall API functions at the top level of a module (i.e. before <code>__init__()</code> has run) so you cannot do <code>const x = pything()</code> at the top level. Instead do <code>const x = pynew()</code> at the top level then <code>pycopy!(x, pything())</code> inside <code>__init__()</code>.</p><p>Assumes <code>dst</code> is NULL, otherwise a memory leak will occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/Py.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.getptr" href="#PythonCall.getptr"><code>PythonCall.getptr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getptr(x)</code></pre><p>Get the underlying pointer from the Python object <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/Py.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pydel!" href="#PythonCall.pydel!"><code>PythonCall.pydel!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pydel!(x::Py)</code></pre><p>Delete the Python object <code>x</code>.</p><p>DANGER! Use this function ONLY IF the Julia object <code>x</code> could have been garbage-collected anyway, i.e. was about to become unreachable. This means you MUST KNOW that no other part of the program has the Julia object <code>x</code>.</p><p>This decrements the reference count, sets the pointer to NULL and appends <code>x</code> to a cache of unused objects (<code>PYNULL_CACHE</code>).</p><p>This is an optimization to avoid excessive allocation and deallocation in Julia, which can be a significant source of slow-down in code which uses a lot of Python objects. It allows <code>pynew()</code> to pop an item from <code>PYNULL_CACHE</code> instead of allocating one, and avoids calling the relatively slow finalizer on <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/Py.jl#L91-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.unsafe_pynext" href="#PythonCall.unsafe_pynext"><code>PythonCall.unsafe_pynext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_pynext(x)</code></pre><p>Return the next item in the iterator <code>x</code>. When there are no more items, return NULL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/6747be4082e77328583e24b515a49ebaf0e61892/src/abstract/iter.jl#L17-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../juliacall/">The Python module JuliaCall »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 3 November 2021 18:55">Wednesday 3 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
