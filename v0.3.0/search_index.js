var documenterSearchIndex = {"docs":
[{"location":"pythoncall/#The-Julia-module-*PythonCall*","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"","category":"section"},{"location":"pythoncall/#Installation","page":"The Julia module PythonCall","title":"Installation","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"This package is in the general registry, so to install just type ] in the Julia REPL and run:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pkg> add PythonCall","category":"page"},{"location":"pythoncall/#Getting-started","page":"The Julia module PythonCall","title":"Getting started","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Import the module with:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"julia> using PythonCall","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"By default this will initialize a conda environment in your Julia environment, install Python into it, load the corresponding Python library and initialize an interpreter.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Now you can interact with Python as follows:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"julia> re = pyimport(\"re\")\nPython module: <module 're' from '[...]/lib/re.py'>\n\njulia> words = re.findall(\"[a-zA-Z]+\", \"PythonCall.jl is very useful!\")\nPython list: ['PythonCall', 'jl', 'is', 'very', 'useful']\n\njulia> sentence = Py(\" \").join(words)\nPython str: 'PythonCall jl is very useful'\n\njulia> pyconvert(String, sentence)\n\"PythonCall jl is very useful\"","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"In this example:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"We used pyimport to import the re module. Equivalently we could have done @py import re (see @py).\nWe called its findall function on a pair of strings, which were automatically converted to Python strings (see Conversion to Python).\nWe called Py to explicitly convert a string to a Python string, so that we could call its join method. All Python objects are of type Py.\nWe called pyconvert to convert the Python string sentence to a Julia string (see Conversion to Julia).","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Read on to find out what else you can do.","category":"page"},{"location":"pythoncall/#Py","page":"The Julia module PythonCall","title":"Py","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Py\n@pyconst","category":"page"},{"location":"pythoncall/#PythonCall.Py","page":"The Julia module PythonCall","title":"PythonCall.Py","text":"Py(x)\n\nConvert x to a Python object.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.@pyconst","page":"The Julia module PythonCall","title":"PythonCall.@pyconst","text":"@pyconst ex\n\nEquivalent to Py(ex) but always returns the exact same Julia object.\n\nThat is, if foo() = @pyconst ex then foo() === foo().\n\nThe expression ex is evaluated the first time the code is run.\n\nIf ex is a string literal, the string is interned.\n\nDo not use this macro at the top level of a module. Instead, use pynew() and pycopy!().\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"The object pybuiltins has all the standard Python builtin objects as its properties. Hence you can access pybuiltins.None and pybuiltins.TypeError.","category":"page"},{"location":"pythoncall/#@py","page":"The Julia module PythonCall","title":"@py","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"@py","category":"page"},{"location":"pythoncall/#PythonCall.@py","page":"The Julia module PythonCall","title":"PythonCall.@py","text":"@py expr\n\nEvaluate the given expression using Pythonic semantics.\n\nFor example:\n\nf(x, y) is translated to pycall(f, x, y)\nx + y is translated to pyadd(x, y)\nx === y is translated to pyis(x, y)\nx.foo is translated to pygetattr(x, \"foo\")\n\nCompound statements such as begin, if, while and for are supported.\n\nSee the online documentation for more details.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#Python-functions","page":"The Julia module PythonCall","title":"Python functions","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Most of the functions in this section are essentially Python builtins with a py prefix. For example pyint(x) converts x to a Python int and is equivalent to int(x) in Python when x is a Python object.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Notable exceptions are:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyconvert to convert a Python object to a Julia object.\npyimport to import a Python module.\npyjl to directly wrap a Julia object as a Python object.\npyclass to construct a new class.\npywith to emulate the Python with statement.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"If a Julia value is passed as an argument to one of these functions, it is converted to a Python value using the rules documented here.","category":"page"},{"location":"pythoncall/#Constructors","page":"The Julia module PythonCall","title":"Constructors","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions construct Python objects of builtin types from Julia values.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pybool\npyint\npyfloat\npycomplex\npystr\npybytes\npytuple\npylist\npycollist\npyrowlist\npyset\npyfrozenset\npydict\npyslice\npyrange\npymethod\npytype\npyclass","category":"page"},{"location":"pythoncall/#PythonCall.pybool","page":"The Julia module PythonCall","title":"PythonCall.pybool","text":"pybool(x)\n\nConvert x to a Python bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyint","page":"The Julia module PythonCall","title":"PythonCall.pyint","text":"pyint(x=0)\n\nConvert x to a Python int.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfloat","page":"The Julia module PythonCall","title":"PythonCall.pyfloat","text":"pyfloat(x=0.0)\n\nConvert x to a Python float.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycomplex","page":"The Julia module PythonCall","title":"PythonCall.pycomplex","text":"pycomplex(x=0.0)\npycomplex(re, im)\n\nConvert x to a Python complex, or create one from given real and imaginary parts.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pystr","page":"The Julia module PythonCall","title":"PythonCall.pystr","text":"pystr(x)\n\nConvert x to a Python str.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybytes","page":"The Julia module PythonCall","title":"PythonCall.pybytes","text":"pybytes(x)\n\nConvert x to a Python bytes.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytuple","page":"The Julia module PythonCall","title":"PythonCall.pytuple","text":"pytuple(x=())\n\nConvert x to a Python tuple.\n\nIf x is a Python object, this is equivalent to tuple(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylist","page":"The Julia module PythonCall","title":"PythonCall.pylist","text":"pylist(x=())\n\nConvert x to a Python list.\n\nIf x is a Python object, this is equivalent to list(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycollist","page":"The Julia module PythonCall","title":"PythonCall.pycollist","text":"pycollist(x::AbstractArray)\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of columns.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrowlist","page":"The Julia module PythonCall","title":"PythonCall.pyrowlist","text":"pyrowlist(x::AbstractArray)\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of rows.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyset","page":"The Julia module PythonCall","title":"PythonCall.pyset","text":"pyset(x=())\n\nConvert x to a Python set.\n\nIf x is a Python object, this is equivalent to set(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfrozenset","page":"The Julia module PythonCall","title":"PythonCall.pyfrozenset","text":"pyfrozenset(x=())\n\nConvert x to a Python frozenset.\n\nIf x is a Python object, this is equivalent to frozenset(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydict","page":"The Julia module PythonCall","title":"PythonCall.pydict","text":"pydict(x)\npydict(; x...)\n\nConvert x to a Python dict. In the second form, the keys are strings.\n\nIf x is a Python object, this is equivalent to dict(x) in Python. Otherwise x must iterate over key-value pairs.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyslice","page":"The Julia module PythonCall","title":"PythonCall.pyslice","text":"pyslice([start], stop, [step])\n\nConstruct a Python slice. Unspecified arguments default to None.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrange","page":"The Julia module PythonCall","title":"PythonCall.pyrange","text":"pyrange([[start], [stop]], [step])\n\nConstruct a Python range. Unspecified arguments default to None.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymethod","page":"The Julia module PythonCall","title":"PythonCall.pymethod","text":"pymethod(x)\n\nConvert callable x to a Python instance method.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytype","page":"The Julia module PythonCall","title":"PythonCall.pytype","text":"pytype(x)\n\nThe Python type of x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyclass","page":"The Julia module PythonCall","title":"PythonCall.pyclass","text":"pyclass(name, bases=(); members...)\n\nConstruct a new Python type with the given name, bases and members.\n\nEquivalent to pytype(name, bases, members).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Builtins","page":"The Julia module PythonCall","title":"Builtins","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions mimic the Python builtin functions or keywords of the same name.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyimport\npywith\npyis\npyrepr\npyascii\npyhasattr\npygetattr\npysetattr\npydelattr\npydir\npycall\npylen\npycontains\npyin\npygetitem\npysetitem\npydelitem\npyissubclass\npyisinstance\npyhash\npyiter","category":"page"},{"location":"pythoncall/#PythonCall.pyimport","page":"The Julia module PythonCall","title":"PythonCall.pyimport","text":"pyimport(m)\npyimport(m => k)\npyimport(m => (k1, k2, ...))\npyimport(m1, m2, ...)\n\nImport a module m, or an attribute k, or a tuple of attributes.\n\nIf several arguments are given, return the results of importing each one in a tuple.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pywith","page":"The Julia module PythonCall","title":"PythonCall.pywith","text":"pywith(f, o, d=nothing)\n\nEquivalent to with o as x: f(x) in Python, where x is a Py.\n\nOn success, the value of f(x) is returned.\n\nIf an exception occurs but is suppressed then d is returned.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyis","page":"The Julia module PythonCall","title":"PythonCall.pyis","text":"pyis(x, y)\n\nTrue if x and y are the same Python object. Equivalent to x is y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrepr","page":"The Julia module PythonCall","title":"PythonCall.pyrepr","text":"pyrepr(x)\n\nEquivalent to repr(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyascii","page":"The Julia module PythonCall","title":"PythonCall.pyascii","text":"pyascii(x)\n\nEquivalent to ascii(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhasattr","page":"The Julia module PythonCall","title":"PythonCall.pyhasattr","text":"pyhasattr(x, k)\n\nEquivalent to hasattr(x, k) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygetattr","page":"The Julia module PythonCall","title":"PythonCall.pygetattr","text":"pygetattr(x, k, [d])\n\nEquivalent to getattr(x, k) or x.k in Python.\n\nIf d is specified, it is returned if the attribute does not exist.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysetattr","page":"The Julia module PythonCall","title":"PythonCall.pysetattr","text":"pysetattr(x, k, v)\n\nEquivalent to setattr(x, k, v) or x.k = v in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydelattr","page":"The Julia module PythonCall","title":"PythonCall.pydelattr","text":"pydelattr(x, k)\n\nEquivalent to delattr(x, k) or del x.k in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydir","page":"The Julia module PythonCall","title":"PythonCall.pydir","text":"pydir(x)\n\nEquivalent to dir(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycall","page":"The Julia module PythonCall","title":"PythonCall.pycall","text":"pycall(f, args...; kwargs...)\n\nCall the Python object f with the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylen","page":"The Julia module PythonCall","title":"PythonCall.pylen","text":"pylen(x)\n\nThe length of x. Equivalent to len(x) in Python, converted to an Integer.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycontains","page":"The Julia module PythonCall","title":"PythonCall.pycontains","text":"pycontains(x, v)\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyin","page":"The Julia module PythonCall","title":"PythonCall.pyin","text":"pyin(v, x)\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygetitem","page":"The Julia module PythonCall","title":"PythonCall.pygetitem","text":"pygetitem(x, k)\n\nEquivalent to getitem(x, k) or x[k] in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysetitem","page":"The Julia module PythonCall","title":"PythonCall.pysetitem","text":"pysetitem(x, k, v)\n\nEquivalent to setitem(x, k, v) or x[k] = v in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydelitem","page":"The Julia module PythonCall","title":"PythonCall.pydelitem","text":"pydelitem(x, k)\n\nEquivalent to delitem(x, k) or del x[k] in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyissubclass","page":"The Julia module PythonCall","title":"PythonCall.pyissubclass","text":"pyissubclass(s, t)\n\nTest if s is a subclass of t. Equivalent to issubclass(s, t) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisinstance","page":"The Julia module PythonCall","title":"PythonCall.pyisinstance","text":"pyisinstance(x, t)\n\nTest if x is of type t. Equivalent to isinstance(x, t) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhash","page":"The Julia module PythonCall","title":"PythonCall.pyhash","text":"pyhash(x)\n\nEquivalent to hash(x) in Python, converted to an Integer.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiter","page":"The Julia module PythonCall","title":"PythonCall.pyiter","text":"pyiter(x)\n\nEquivalent to iter(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Conversion-to-Julia","page":"The Julia module PythonCall","title":"Conversion to Julia","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions convert Python values to Julia values, using the rules documented here.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyconvert\n@pyconvert","category":"page"},{"location":"pythoncall/#PythonCall.pyconvert","page":"The Julia module PythonCall","title":"PythonCall.pyconvert","text":"pyconvert(T, x, [d])\n\nConvert the Python object x to a T.\n\nIf d is specified, it is returned on failure instead of throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.@pyconvert","page":"The Julia module PythonCall","title":"PythonCall.@pyconvert","text":"@pyconvert(T, x, [onfail])\n\nConvert the Python object x to a T.\n\nOn failure, evaluates to onfail, which defaults to return pyconvert_unconverted() (mainly useful for writing conversion rules).\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#Wrap-Julia-values","page":"The Julia module PythonCall","title":"Wrap Julia values","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions explicitly wrap Julia values into Python objects, documented here.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"As documented here, Julia values are wrapped like this automatically on conversion to Python, unless the value is immutable and has a corresponding Python type.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyjl\npyjlraw\npyisjl\npyjlvalue\npytextio\npybinaryio","category":"page"},{"location":"pythoncall/#PythonCall.pyjl","page":"The Julia module PythonCall","title":"PythonCall.pyjl","text":"pyjl([t], x)\n\nCreate a Python object wrapping the Julia object x.\n\nIf x is mutable, then mutating the returned object also mutates x, and vice versa.\n\nIts Python type is normally inferred from the type of x, but can be specified with t.\n\nFor example if x is an AbstractVector then the object will have type juliacall.VectorValue. This object will satisfy the Python sequence interface, so for example uses 0-up indexing.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyjlraw","page":"The Julia module PythonCall","title":"PythonCall.pyjlraw","text":"pyjlraw(v)\n\nCreate a Python object wrapping the Julia object x.\n\nIt has type juliacall.RawValue. This has a much more rigid \"Julian\" interface than pyjl(v). For example, accessing attributes or calling this object will always return a RawValue.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisjl","page":"The Julia module PythonCall","title":"PythonCall.pyisjl","text":"pyisjl(x)\n\nTest whether x is a wrapped Julia value, namely an instance of juliacall.ValueBase.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyjlvalue","page":"The Julia module PythonCall","title":"PythonCall.pyjlvalue","text":"pyjlvalue(x)\n\nExtract the value from the wrapped Julia value x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytextio","page":"The Julia module PythonCall","title":"PythonCall.pytextio","text":"pytextio(io::IO)\n\nWrap io as a Python text IO object.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybinaryio","page":"The Julia module PythonCall","title":"PythonCall.pybinaryio","text":"pybinaryio(io::IO)\n\nWrap io as a Python binary IO object.\n\nThis is the default behaviour of Py(io).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Arithmetic","page":"The Julia module PythonCall","title":"Arithmetic","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions are equivalent to the corresponding Python arithmetic operators.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Note that the equivalent Julia operators are overloaded to call these when all arguments are Py (or Number). Hence the following are equivalent: Py(1)+Py(2), Py(1)+2, pyadd(1, 2), pyadd(Py(1), Py(2)), etc.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyneg\npypos\npyabs\npyinv\npyindex\npyadd\npysub\npymul\npymatmul\npypow\npyfloordiv\npytruediv\npymod\npydivmod\npylshift\npyrshift\npyand\npyxor\npyor\npyiadd\npyisub\npyimul\npyimatmul\npyipow\npyifloordiv\npyitruediv\npyimod\npyilshift\npyirshift\npyiand\npyixor\npyior","category":"page"},{"location":"pythoncall/#PythonCall.pyneg","page":"The Julia module PythonCall","title":"PythonCall.pyneg","text":"pyneg(x)\n\nEquivalent to -x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pypos","page":"The Julia module PythonCall","title":"PythonCall.pypos","text":"pypos(x)\n\nEquivalent to +x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyabs","page":"The Julia module PythonCall","title":"PythonCall.pyabs","text":"pyabs(x)\n\nEquivalent to abs(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyinv","page":"The Julia module PythonCall","title":"PythonCall.pyinv","text":"pyinv(x)\n\nEquivalent to ~x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyindex","page":"The Julia module PythonCall","title":"PythonCall.pyindex","text":"pyindex(x)\n\nConvert x losslessly to an int.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyadd","page":"The Julia module PythonCall","title":"PythonCall.pyadd","text":"pyadd(x, y)\n\nEquivalent to x + y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysub","page":"The Julia module PythonCall","title":"PythonCall.pysub","text":"pysub(x, y)\n\nEquivalent to x - y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymul","page":"The Julia module PythonCall","title":"PythonCall.pymul","text":"pymul(x, y)\n\nEquivalent to x * y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymatmul","page":"The Julia module PythonCall","title":"PythonCall.pymatmul","text":"pymatmul(x, y)\n\nEquivalent to x @ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pypow","page":"The Julia module PythonCall","title":"PythonCall.pypow","text":"pypow(x, y, z=None)\n\nEquivalent to x ** y or pow(x, y, z) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfloordiv","page":"The Julia module PythonCall","title":"PythonCall.pyfloordiv","text":"pyfloordiv(x, y)\n\nEquivalent to x // y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytruediv","page":"The Julia module PythonCall","title":"PythonCall.pytruediv","text":"pytruediv(x, y)\n\nEquivalent to x / y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymod","page":"The Julia module PythonCall","title":"PythonCall.pymod","text":"pymod(x, y)\n\nEquivalent to x % y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydivmod","page":"The Julia module PythonCall","title":"PythonCall.pydivmod","text":"pydivmod(x, y)\n\nEquivalent to divmod(x, y) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylshift","page":"The Julia module PythonCall","title":"PythonCall.pylshift","text":"pylshift(x, y)\n\nEquivalent to x << y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrshift","page":"The Julia module PythonCall","title":"PythonCall.pyrshift","text":"pyrshift(x, y)\n\nEquivalent to x >> y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyand","page":"The Julia module PythonCall","title":"PythonCall.pyand","text":"pyand(x, y)\n\nEquivalent to x & y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyxor","page":"The Julia module PythonCall","title":"PythonCall.pyxor","text":"pyxor(x, y)\n\nEquivalent to x ^ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyor","page":"The Julia module PythonCall","title":"PythonCall.pyor","text":"pyor(x, y)\n\nEquivalent to x | y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiadd","page":"The Julia module PythonCall","title":"PythonCall.pyiadd","text":"pyiadd(x, y)\n\nIn-place add. x = pyiadd(x, y) is equivalent to x += y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisub","page":"The Julia module PythonCall","title":"PythonCall.pyisub","text":"pyisub(x, y)\n\nIn-place subtract. x = pyisub(x, y) is equivalent to x -= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimul","page":"The Julia module PythonCall","title":"PythonCall.pyimul","text":"pyimul(x, y)\n\nIn-place multiply. x = pyimul(x, y) is equivalent to x *= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimatmul","page":"The Julia module PythonCall","title":"PythonCall.pyimatmul","text":"pyimatmul(x, y)\n\nIn-place matrix multiply. x = pyimatmul(x, y) is equivalent to x @= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyipow","page":"The Julia module PythonCall","title":"PythonCall.pyipow","text":"pyipow(x, y, z=None)\n\nIn-place power. x = pyipow(x, y) is equivalent to x **= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyifloordiv","page":"The Julia module PythonCall","title":"PythonCall.pyifloordiv","text":"pyifloordiv(x, y)\n\nIn-place floor divide. x = pyifloordiv(x, y) is equivalent to x //= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyitruediv","page":"The Julia module PythonCall","title":"PythonCall.pyitruediv","text":"pyitruediv(x, y)\n\nIn-place true division. x = pyitruediv(x, y) is equivalent to x /= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimod","page":"The Julia module PythonCall","title":"PythonCall.pyimod","text":"pyimod(x, y)\n\nIn-place subtraction. x = pyimod(x, y) is equivalent to x %= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyilshift","page":"The Julia module PythonCall","title":"PythonCall.pyilshift","text":"pyilshift(x, y)\n\nIn-place left shift. x = pyilshift(x, y) is equivalent to x <<= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyirshift","page":"The Julia module PythonCall","title":"PythonCall.pyirshift","text":"pyirshift(x, y)\n\nIn-place right shift. x = pyirshift(x, y) is equivalent to x >>= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiand","page":"The Julia module PythonCall","title":"PythonCall.pyiand","text":"pyiand(x, y)\n\nIn-place and. x = pyiand(x, y) is equivalent to x &= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyixor","page":"The Julia module PythonCall","title":"PythonCall.pyixor","text":"pyixor(x, y)\n\nIn-place xor. x = pyixor(x, y) is equivalent to x ^= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyior","page":"The Julia module PythonCall","title":"PythonCall.pyior","text":"pyior(x, y)\n\nIn-place or. x = pyior(x, y) is equivalent to x |= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Logic","page":"The Julia module PythonCall","title":"Logic","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions are equivalent to the corresponding Python logical operators.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Note that the equivalent Julia operators are overloaded to call these when all arguments are Py (or Number). Hence the following are equivalent: Py(1) < Py(2), Py(1) < 2, pylt(1, 2), pylt(Py(1), Py(2)), etc.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Note that the binary operators by default return Py (not Bool) since comparisons in Python do not necessarily return bool.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pytruth\npynot\npyeq\npyne\npyle\npylt\npyge\npygt","category":"page"},{"location":"pythoncall/#PythonCall.pytruth","page":"The Julia module PythonCall","title":"PythonCall.pytruth","text":"pytruth(x)\n\nThe truthyness of x. Equivalent to bool(x) in Python, converted to a Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pynot","page":"The Julia module PythonCall","title":"PythonCall.pynot","text":"pynot(x)\n\nThe falsyness of x. Equivalent to not x in Python, converted to a Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyeq","page":"The Julia module PythonCall","title":"PythonCall.pyeq","text":"pyeq(x, y)\npyeq(Bool, x, y)\n\nEquivalent to x == y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyne","page":"The Julia module PythonCall","title":"PythonCall.pyne","text":"pyne(x, y)\npyne(Bool, x, y)\n\nEquivalent to x != y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyle","page":"The Julia module PythonCall","title":"PythonCall.pyle","text":"pyle(x, y)\npyle(Bool, x, y)\n\nEquivalent to x <= y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylt","page":"The Julia module PythonCall","title":"PythonCall.pylt","text":"pylt(x, y)\npylt(Bool, x, y)\n\nEquivalent to x < y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyge","page":"The Julia module PythonCall","title":"PythonCall.pyge","text":"pyge(x, y)\npyge(Bool, x, y)\n\nEquivalent to x >= y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygt","page":"The Julia module PythonCall","title":"PythonCall.pygt","text":"pygt(x, y)\npygt(Bool, x, y)\n\nEquivalent to x > y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Managing-Python-dependencies","page":"The Julia module PythonCall","title":"Managing Python dependencies","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"PythonCall manages its Python dependencies using Conda. A Conda environment is automatically created in your active Julia environment when PythonCall is loaded, is initialised with at least python and pip, and is activated.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"If your project requires more Python dependencies, use the mechanisms below to ensure they are automatically installed.","category":"page"},{"location":"pythoncall/#PythonCallDeps.toml","page":"The Julia module PythonCall","title":"PythonCallDeps.toml","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"If you put a file called PythonCallDeps.toml in a project/package/environment which depends on PythonCall, then the dependencies therein will be automatically installed into the Conda environment.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Here is an example (all parts are optional):","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"[conda]\npackages = [\"python>=3.6\", \"scikit-learn\"]\nchannels = [\"conda-forge\"]\n\n[pip]\npackages = [\"numpy>=1.21\"]\n# indexes = [...]\n\n[script]\n# expr = \"some_julia_expression()\"\n# file = \"/path/to/julia/script.jl\"","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"When PythonCall starts, it will ensure the Conda environment has the given Conda and pip packages installed, and will run the script if specified.","category":"page"},{"location":"pythoncall/#The-Deps-submodule","page":"The Julia module PythonCall","title":"The Deps submodule","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Instead of manually editing PythonCallDeps.toml, you can use the submodule PythonCall.Deps to manage the Python dependencies of the current Julia project.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"PythonCall.Deps.status\nPythonCall.Deps.add\nPythonCall.Deps.rm\nPythonCall.Deps.resolve\nPythonCall.Deps.conda_env\nPythonCall.Deps.user_deps_file","category":"page"},{"location":"pythoncall/#PythonCall.Deps.status","page":"The Julia module PythonCall","title":"PythonCall.Deps.status","text":"status()\n\nDisplay the status of dependencies of the current Julia project.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.Deps.add","page":"The Julia module PythonCall","title":"PythonCall.Deps.add","text":"add(...)\n\nAdd Python dependencies to the current Julia project.\n\nKeyword arguments (all optional):\n\nconda_channels: An iterable of conda channels to use.\nconda_packages: An iterable of conda packages to install.\npip_indexes: An iterable of pip indexes to use.\npip_packages: An iterable of pip packages to install.\nscript_expr: An expression to evaluate in the Deps module.\nscript_file: The path to a Julia file to evaluate in the Deps module.\nresolve=true: When true, immediately resolve the dependencies. Otherwise, the dependencies are not resolved until you call resolve or load PythonCall in a new Julia session.\ncreate=true: When true, creates the environment from scratch when resolving.\n\nThe conda and pip packages can include version specifiers, such as python>=3.6.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.Deps.rm","page":"The Julia module PythonCall","title":"PythonCall.Deps.rm","text":"rm(...)\n\nRemove Python dependencies from the current Julia project.\n\nKeyword arguments (all optional):\n\nconda_channels: An iterable of conda channels to remove.\nconda_packages: An iterable of conda packages to remove.\npip_indexes: An iterable of pip indexes to remove.\npip_packages: An iterable of pip packages to remove.\nscript_expr=false: When true, remove the script expression.\nscript_file=false: When true, remove the script file.\nresolve=true: When true, immediately resolve the dependencies. Otherwise, the dependencies are not resolved until you call resolve or load PythonCall in a new Julia session.\ncreate=true: When true, creates the environment from scratch when resolving.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.Deps.resolve","page":"The Julia module PythonCall","title":"PythonCall.Deps.resolve","text":"resolve(; create=true, force=false)\n\nResolve all Python dependencies.\n\nIf create=true then a new Conda environment is created and activated. Otherwise, the existing one is updated.\n\nBy default, if no dependencies have actually changed, then resolving them is skipped. Specify force=true to skip this check and force resolving dependencies.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.Deps.conda_env","page":"The Julia module PythonCall","title":"PythonCall.Deps.conda_env","text":"conda_env()\n\nThe path to the Conda environment in which Python dependencies are managed.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.Deps.user_deps_file","page":"The Julia module PythonCall","title":"PythonCall.Deps.user_deps_file","text":"user_deps_file()\n\nThe path to the PythonCallDeps.toml file in the active environment.\n\n\n\n\n\n","category":"function"},{"location":"juliacall/#The-Python-module-*juliacall*","page":"The Python module juliacall","title":"The Python module juliacall","text":"","category":"section"},{"location":"juliacall/#Installation","page":"The Python module juliacall","title":"Installation","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"In the future, the package will be available on PyPI and conda. For now, you can pip install this package directly from github as follows:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"pip install git+https://github.com/cjdoris/PythonCall.jl","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"Developers may wish to clone the repo directly and pip install the module in editable mode. This guarantees you are using the latest version of PythonCall in conjunction with juliacall.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"Note also that regardless of installing juliacall, a module called juliacall will always be loaded into the interpreter by PythonCall. This means that other Python packages can always import juliacall.","category":"page"},{"location":"juliacall/#Getting-started","page":"The Python module juliacall","title":"Getting started","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"For interactive or scripting use, the simplest way to get started is:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"from juliacall import Main as jl","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"This loads a single variable jl (a ModuleValue) which represents the Main module in Julia, from which all of Julia's functionality is available.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"If you are writing a package which uses Julia, then to avoid polluting the global Main namespace you should do:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"import juliacall; jl = juliacall.newmodule(\"SomeName\");","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"Now you can do jl.rand(jl.Bool, 5, 5), which is equivalent to rand(Bool, 5, 5) in Julia.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"When a Python value is passed to Julia, then typically it will be converted according to this table with T=Any. Sometimes a more specific type will be used, such as when assigning to an array whose element type is known.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"When a Julia value is returned to Python, it will normally be converted according to this table.","category":"page"},{"location":"juliacall/#Managing-Julia-dependencies","page":"The Python module juliacall","title":"Managing Julia dependencies","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall manages its Julia dependencies using Pkg for packages and jill for Julia itself. If a suitable version of julia is not found on your system, it will automatically be downloaded and installed into ~/.julia/pythoncall. A Julia environment is automatically created when juliacall is loaded, is activated, and is initialised with at least PythonCall. If you are using a virtual or conda environment then the Julia environment is created there, otherwise a global environment is created at ~/.julia/environments/PythonCall.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"If your project requires more Julia dependencies, use the mechanisms below to ensure they are automatically installed.","category":"page"},{"location":"juliacall/#juliacalldeps.json","page":"The Python module juliacall","title":"juliacalldeps.json","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"If you put a file called juliacalldeps.json in a Python package, then the dependencies therein will be automatically installed into the Julia environment.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"Here is an example:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"{\n    \"julia\": \"1.5\",\n    \"packages\": {\n        \"Example\": {\n            \"uuid\": \"7876af07-990d-54b4-ab0e-23690620f79a\",\n            \"compat\": \"0.5\",\n            \"url\": \"http://github.com/JuliaLang/Example.jl\",\n            \"path\": \"/path/to/the/package\",\n            \"rev\": \"master\",\n            \"dev\": false, // when true, uses Pkg.dev not Pkg.add\n        }\n    }\n}","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"All parts are optional, except that the UUID of each package is required.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"When juliacall starts, it will ensure the latest compatible version of julia is installed, and will ensure the given packages are installed.","category":"page"},{"location":"juliacall/#Utilities","page":"The Python module juliacall","title":"Utilities","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.newmodule - Function\n\n```python\nnewmodule(name)\n```\n\nA new module with the given name.","category":"page"},{"location":"juliacall/#juliacall.newmodule","page":"The Python module juliacall","title":"juliacall.newmodule","text":"newmodule(name)\n\nA new module with the given name.\n\n","category":"function"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.As - Class\n\n```python\nAs(x, T)\n```\n\nWhen passed as an argument to a Julia function, is interpreted as `x` converted to Julia type `T`.","category":"page"},{"location":"juliacall/#juliacall.As","page":"The Python module juliacall","title":"juliacall.As","text":"As(x, T)\n\nWhen passed as an argument to a Julia function, is interpreted as x converted to Julia type T.\n\n","category":"class"},{"location":"conversion-to-python/#jl2py","page":"Conversion to Python","title":"Conversion to Python","text":"","category":"section"},{"location":"conversion-to-python/#Conversion-Rules","page":"Conversion to Python","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"From Julia, one converts Julia objects to Python explicitly using Py(x) or implicitly by passing the value to one of the many other functions, such as pygetattr(x, \"append\").","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"From Python, calling a Julia function or indexing a Julia object, etc., will convert the result to some Python object.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"The following table specifies the conversion rules used whenever converting a Julia object to a Python object.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"The user can always explicitly choose a different conversion (e.g. by calling pylist or pydict).","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"From To\nAny Python object type (Py, PyList, etc.) itself\nNothing, Missing None\nBool bool\nStandard integer (IntXX, UIntXX, BigInt) int\nStandard rational (Rational{T}, T a standard integer) fractions.Fraction\nStandard float (FloatXX) float\nStandard complex (Complex{T}, T a standard float) complex\nStandard string/char (String and SubString{String}, Char) str\nTuple tuple\nStandard integer range (AbstractRange{T}, T a standard integer) range\nDate, Time, DateTime (from Dates) date, time, datetime (from datetime)\nSecond, Millisecond, Microsecond, Nanosecond (from Dates) timedelta (from datetime)\nNumber juliacall.NumberValue, juliacall.ComplexValue, etc.\nAbstractArray juliacall.ArrayValue, juliacall.VectorValue\nAbstractDict juliacall.DictValue\nAbstractSet juliacall.SetValue\nIO juliacall.BufferedIOValue\nModule juliacall.ModuleValue\nType juliacall.TypeValue\nAnything else juliacall.AnyValue","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"See below for an explanation of the juliacall.*Value types.","category":"page"},{"location":"conversion-to-python/#julia-wrappers","page":"Conversion to Python","title":"Wrapper types","text":"","category":"section"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"Apart from a few fundamental immutable types, all Julia values are by default converted into Python to some AnyValue object, which wraps the original value, but giving it a Pythonic interface.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"Some types are converted to a subclass of AnyValue which provides additional Python semantics –- e.g. Julia vectors are interpreted as Python sequences.","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"There is also a RawValue object, which gives a stricter \"Julia-only\" interface, documented below. These types all inherit from ValueBase:","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"ValueBase\nRawValue\nAnyValue\nNumberValue\nComplexValue\nRealValue\nRationalValue\nIntegerValue\nArrayValue\nVectorValue\nDictValue\nSetValue\nIOValue\nBinaryIOValue\nTextIOValue\nModuleValue\nTypeValue","category":"page"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.AnyValue - Class\n\nWraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports `repr(x)`, `str(x)`, attributes (`x.attr`), calling (`x(a,b)`), iteration, comparisons, `len(x)`, `a in x`, `dir(x)`.\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to [this table](@ref jl2py). This is typically a builtin Python type (for immutables) or a subtype of `AnyValue`.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, `_b` at the end of an attribute is replaced with `!` and `_bb` is replaced with `!!`.\n\n###### Members\n- `_jl_raw()`: Convert to a [`RawValue`](#juliacall.RawValue). (See also [`pyjlraw`](@ref).)\n- `_jl_display()`: Display the object using Julia's display mechanism.\n- `_jl_help()`: Display help for the object.","category":"page"},{"location":"conversion-to-python/#juliacall.AnyValue","page":"Conversion to Python","title":"juliacall.AnyValue","text":"Wraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), iteration, comparisons, len(x), a in x, dir(x).\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to this table. This is typically a builtin Python type (for immutables) or a subtype of AnyValue.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, _b at the end of an attribute is replaced with ! and _bb is replaced with !!.\n\nMembers\n\n_jl_raw(): Convert to a RawValue. (See also pyjlraw.)\n_jl_display(): Display the object using Julia's display mechanism.\n_jl_help(): Display help for the object.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.NumberValue - Class\n\nThis wraps any Julia `Number` value. It is a subclass of `numbers.Number` and behaves similar to other Python numbers.\n\nThere are also subtypes `ComplexValue`, `RealValue`, `RationalValue`, `IntegerValue` which wrap values of the corresponding Julia types, and are subclasses of the corresponding `numbers` ABC.","category":"page"},{"location":"conversion-to-python/#juliacall.NumberValue","page":"Conversion to Python","title":"juliacall.NumberValue","text":"This wraps any Julia Number value. It is a subclass of numbers.Number and behaves similar to other Python numbers.\n\nThere are also subtypes ComplexValue, RealValue, RationalValue, IntegerValue which wrap values of the corresponding Julia types, and are subclasses of the corresponding numbers ABC.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.ArrayValue - Class\n\nThis wraps any Julia `AbstractArray` value. It is a subclass of `collections.abc.Collection`.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nThere is also the subtype `VectorValue` which wraps any `AbstractVector`. It is a subclass of `collections.abc.Sequence` and behaves similar to a Python `list`.\n\nIf the array is strided and its eltype is supported (i.e. `Bool`, `IntXX`, `UIntXX`, `FloatXX`, `Complex{FloatXX}`, `Ptr{Cvoid}` or `Tuple` or `NamedTuple` of these) then it supports the buffer protocol and the numpy array interface. This means that `numpy.asarray(this)` will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy `__array__` method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, `numpy.asarray(this)` is a copy of the original array.\n\n###### Members\n- `ndim`: The number of dimensions.\n- `shape`: Tuple of lengths in each dimension.\n- `copy()`: A copy of the array.\n- `reshape(shape)`: A reshaped view of the array.","category":"page"},{"location":"conversion-to-python/#juliacall.ArrayValue","page":"Conversion to Python","title":"juliacall.ArrayValue","text":"This wraps any Julia AbstractArray value. It is a subclass of collections.abc.Collection.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nThere is also the subtype VectorValue which wraps any AbstractVector. It is a subclass of collections.abc.Sequence and behaves similar to a Python list.\n\nIf the array is strided and its eltype is supported (i.e. Bool, IntXX, UIntXX, FloatXX, Complex{FloatXX}, Ptr{Cvoid} or Tuple or NamedTuple of these) then it supports the buffer protocol and the numpy array interface. This means that numpy.asarray(this) will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy __array__ method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, numpy.asarray(this) is a copy of the original array.\n\nMembers\n\nndim: The number of dimensions.\nshape: Tuple of lengths in each dimension.\ncopy(): A copy of the array.\nreshape(shape): A reshaped view of the array.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.DictValue - Class\nThis wraps any Julia `AbstractDict` value. It is a subclass of `collections.abc.Mapping` and behaves similar to a Python `dict`.","category":"page"},{"location":"conversion-to-python/#juliacall.DictValue","page":"Conversion to Python","title":"juliacall.DictValue","text":"This wraps any Julia AbstractDict value. It is a subclass of collections.abc.Mapping and behaves similar to a Python dict.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.SetValue - Class\nThis wraps any Julia `AbstractSet` value. It is a subclass of `collections.abc.Set` and behaves similar to a Python `set`.","category":"page"},{"location":"conversion-to-python/#juliacall.SetValue","page":"Conversion to Python","title":"juliacall.SetValue","text":"This wraps any Julia AbstractSet value. It is a subclass of collections.abc.Set and behaves similar to a Python set.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.IOValue - Class\n\nThis wraps any Julia `IO` value. It is a subclass of `io.IOBase` and behaves like Python files.\n\nThere are also subtypes `BinaryIOValue` and `TextIOValue`, which are subclasses of `io.BufferedIOBase` (buffered bytes) and `io.TextIOBase` (text).","category":"page"},{"location":"conversion-to-python/#juliacall.IOValue","page":"Conversion to Python","title":"juliacall.IOValue","text":"This wraps any Julia IO value. It is a subclass of io.IOBase and behaves like Python files.\n\nThere are also subtypes BinaryIOValue and TextIOValue, which are subclasses of io.BufferedIOBase (buffered bytes) and io.TextIOBase (text).\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.ModuleValue - Class\nThis wraps any Julia `Module` value.\n\nIt is the same as [`AnyValue`](#juliacall.AnyValue) except for one additional convenience method:\n- `seval([module=self], code)`: Evaluates the given code (a string) in the given module.","category":"page"},{"location":"conversion-to-python/#juliacall.ModuleValue","page":"Conversion to Python","title":"juliacall.ModuleValue","text":"This wraps any Julia Module value.\n\nIt is the same as AnyValue except for one additional convenience method:\n\nseval([module=self], code): Evaluates the given code (a string) in the given module.\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.TypeValue - Class\n\nThis wraps any Julia `Type` value.\n\nIt is the same as [`AnyValue`](#juliacall.AnyValue) except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\n```python\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n```","category":"page"},{"location":"conversion-to-python/#juliacall.TypeValue","page":"Conversion to Python","title":"juliacall.TypeValue","text":"This wraps any Julia Type value.\n\nIt is the same as AnyValue except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n\n","category":"class"},{"location":"conversion-to-python/","page":"Conversion to Python","title":"Conversion to Python","text":"juliacall.RawValue - Class\n\nWraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports `repr(x)`, `str(x)`, attributes (`x.attr`), calling (`x(a,b)`), `len(x)`, `dir(x)`.\n\nThis is very similar to [`AnyValue`](#juliacall.AnyValue) except that indexing, calling, etc. will always return a `RawValue`.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\n###### Members\n- `_jl_any()`: Convert to a [`AnyValue`](#juliacall.AnyValue) (or subclass). (See also [`pyjl`](@ref).)","category":"page"},{"location":"conversion-to-python/#juliacall.RawValue","page":"Conversion to Python","title":"juliacall.RawValue","text":"Wraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), len(x), dir(x).\n\nThis is very similar to AnyValue except that indexing, calling, etc. will always return a RawValue.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\nMembers\n\n_jl_any(): Convert to a AnyValue (or subclass). (See also pyjl.)\n\n","category":"class"},{"location":"compat/#Compatibility-Tools","page":"Compatibility Tools","title":"Compatibility Tools","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Some packages require a little extra help to work nicely with PythonCall.jl.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Some of these are \"fixes\" that are silently applied for you, and some are just extra functions to bridge a gap. We aim to keep these as minimal as possible.","category":"page"},{"location":"compat/#Stdlib","page":"Compatibility Tools","title":"Stdlib","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Whenever a Python exception is displayed by Julia, sys.last_traceback and friends are set. This allows the post-mortem debugger pdb.pm() to work. Disable by setting PythonCall.CONFIG.auto_sys_last_traceback = false.","category":"page"},{"location":"compat/#Tabular-data-and-Pandas","page":"Compatibility Tools","title":"Tabular data & Pandas","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"A pandas.DataFrame can be wrapped in Julia as a PyPandasDataFrame, providing a Tables.jl-compatible interface.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Furthermore, any Python object which can be converted to a PyTable (e.g. pandas.DataFrame can be converted to PyPandasDataFrame) satisfies the Tables.jl interface.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"In the other direction, the following functions can be used to convert any Tables.jl-compatible table to a Python table.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"pytable","category":"page"},{"location":"compat/#PythonCall.pytable","page":"Compatibility Tools","title":"PythonCall.pytable","text":"pytable(src, format=:pandas; ...)\n\nConstruct a Python table from the Tables.jl-compatible table src.\n\nThe format controls the type of the resulting table, and is one of:\n\n:pandas: A pandas.DataFrame. Keyword arguments are passed to the DataFrame constructor.\n:columns: A dict mapping column names to columns.\n:rows: A list of rows, which are namedtuples.\n:rowdicts: A list of rows, which are dicts.\n\n\n\n\n\n","category":"function"},{"location":"compat/#MatPlotLib-/-PyPlot","page":"Compatibility Tools","title":"MatPlotLib / PyPlot","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"pyplot_show","category":"page"},{"location":"compat/#PythonCall.pyplot_show","page":"Compatibility Tools","title":"PythonCall.pyplot_show","text":"pyplot_show([fig]; close=true, [format])\n\nShow the matplotlib/pyplot/seaborn/etc figure fig, or all open figures if not given, using Julia's display mechanism.\n\nIf close is true, the figure is also closed.\n\nThe format specifies the file format of the generated image. By default this is pyplot.rcParams[\"savefig.format\"] or \"png\". It can be one of \"png\", \"jpg\", \"jpeg\", \"tif\", \"tiff\", \"svg\" or \"pdf\".\n\n\n\n\n\n","category":"function"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If Julia is running an IJulia kernel, pyplot_show() is automatically called after executing a cell, so that plots generated in a cell are always shown (similar to IPython). It can be disabled by setting PythonCall.CONFIG.auto_pyplot_show = false.","category":"page"},{"location":"compat/#GUIs-(including-MatPlotLib)","page":"Compatibility Tools","title":"GUIs (including MatPlotLib)","text":"","category":"section"},{"location":"compat/#Event-loops","page":"Compatibility Tools","title":"Event loops","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If for example you wish to use PyPlot in interactive mode (matplotlib.pyplot.ion()) then activating the correct event loop will allow it to work.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"PythonCall.event_loop_on\nPythonCall.event_loop_off","category":"page"},{"location":"compat/#PythonCall.event_loop_on","page":"Compatibility Tools","title":"PythonCall.event_loop_on","text":"event_loop_on(g::Symbol; interval=0.04, fix=false)\n\nActivate an event loop for the GUI framework g, so that the framework can run in the background of a Julia session.\n\nThe event loop runs every interval seconds. If fix is true and g is a Qt framework, then fix_qt_plugin_path is called.\n\nSupported values of g (and the Python module they relate to) are: :pyqt4 (PyQt4), :pyqt5 (PyQt5), :pyside (PySide), :pyside2 (PySide2), :gtk (gtk), :gtk3 (gi), :wx (wx), :tkinter (tkinter).\n\n\n\n\n\n","category":"function"},{"location":"compat/#PythonCall.event_loop_off","page":"Compatibility Tools","title":"PythonCall.event_loop_off","text":"event_loop_off(g::Symbol)\n\nTerminate the event loop g if it is running.\n\n\n\n\n\n","category":"function"},{"location":"compat/#Qt-path-fix","page":"Compatibility Tools","title":"Qt path fix","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"PythonCall.fix_qt_plugin_path","category":"page"},{"location":"compat/#PythonCall.fix_qt_plugin_path","page":"Compatibility Tools","title":"PythonCall.fix_qt_plugin_path","text":"fix_qt_plugin_path()\n\nTry to set the QT_PLUGIN_PATH environment variable in Python, if not already set.\n\nThis fixes the problem that Qt does not know where to find its qt.conf file, because it always looks relative to sys.executable, which can be the Julia executable not the Python one when using this package.\n\nIf CONFIG.auto_fix_qt_plugin_path is true, then this is run automatically before PyQt4, PyQt5, PySide or PySide2 are imported.\n\n\n\n\n\n","category":"function"},{"location":"compat/#IPython","page":"Compatibility Tools","title":"IPython","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If Python is running an IPython kernel, then:","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Julia's Base.stdout is set to Python's sys.stdout.\nAn IPythonDisplay is pushed onto Julia's display stack, so that display(x) goes to IPython if possible.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"This is disabled by setting PythonCall.CONFIG.auto_ipython_display = false.","category":"page"},{"location":"#PythonCall.jl","page":"Home","title":"PythonCall.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bringing Python® and Julia together in seamless harmony:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Call Python code from Julia and Julia code from Python via a symmetric interface.\nSimple syntax, so the Python code looks like Python and the Julia code looks like Julia.\nIntuitive and flexible conversions between Julia and Python: anything can be converted, you are in control.\nFast non-copying conversion of numeric arrays in either direction: modify Python arrays (e.g. bytes, array.array, numpy.ndarray) from Julia or Julia arrays from Python.\nHelpful wrappers: interpret Python sequences, dictionaries, arrays, dataframes and IO streams as their Julia couterparts, and vice versa.\nBeautiful stack-traces.\nWorks anywhere: tested on Windows, MacOS and Linux, 32- and 64-bit, Julia 1.0 upwards and Python 3.5 upwards.","category":"page"},{"location":"conversion-to-julia/#py2jl","page":"Conversion to Julia","title":"Conversion to Julia","text":"","category":"section"},{"location":"conversion-to-julia/#Conversion-Rules","page":"Conversion to Julia","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"From Julia, one can convert Python objects to a desired type using pyconvert(T, x) for example.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"From Python, when a value is passed to Julia, it is typically converted to a corresponding Julia value using pyconvert(Any, x).","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"Quite general conversions are allowed, and the target type T can be as specific as you like. For example","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"@pyv `[1, None, 3]`::Tuple{Vararg{Union{AbstractFloat,Missing}}}","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"evaluates to (1.0, missing, 2.0).","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"The following table specifies the conversion rules in place. If the initial Python type matches the \"From\" column and the desired type T intersects with the \"To\" column, then that conversion is attempted. Conversions are tried in priority order, then in specificity order.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"From To\nTop priority (wrapped values). \njuliacall.AnyValue Any\nVery high priority (arrays). \nObjects satisfying the buffer or array interface (inc. bytes, bytearray, array.array, numpy.ndarray) PyArray\nHigh priority (canonical conversions). \nNone Nothing\nbool Bool\nnumbers.Integral (inc. int) Integer (prefers Int, or BigInt on overflow)\nfloat Float64\ncomplex Complex{Float64}\nrange StepRange\nstr String\ntuple Tuple\ncollections.abc.Mapping (inc. dict) PyDict\ncollections.abc.Sequence (inc. list) PyList\ncollections.abc.Set (inc. set, frozenset) PySet\nio.IOBase (includes open files) PyIO\ndatetime.date/datetime.time/datetime.datetime Date/Time/DateTime\ndatetime.timedelta Microsecond (or Millisecond or Second on overflow)\nnumpy.intXX/numpy.uintXX/numpy.floatXX IntXX/UIntXX/FloatXX\nStandard priority (other reasonable conversions). \nNone Missing\nbytes Vector{UInt8}, Vector{Int8}, String\nstr String, Symbol, Char, Vector{UInt8}, Vector{Int8}\nrange UnitRange\ncollections.abc.Mapping Dict\ncollections.abc.Iterable Vector, Set, Tuple, NamedTuple, Pair\ndatetime.timedelta Dates.CompoundPeriod\nnumbers.Integral Integer, Rational, Real, Number\nnumbers.Real AbstractFloat, Number, Missing/Nothing (if NaN)\nnumbers.Complex Complex, Number\nctypes.c_int and other integers Integer, Rational, Real, Number\nctypes.c_float/ctypes.c_double Cfloat/Cdouble, AbstractFloat, Real, Number\nctypes.c_voidp Ptr{Cvoid}, Ptr\nctypes.c_char_p Cstring, Ptr{Cchar}, Ptr\nctypes.c_wchar_p Cwstring, Ptr{Cwchar}, Ptr\nnumpy.intXX/numpy.uintXX/numpy.floatXX Integer, Rational, Real, Number\nObjects satisfying the buffer or array interface Array\nLow priority (fallback to Py). \nAnything Py\nBottom priority (must be explicitly specified by excluding Py). \nObjects satisfying the buffer interface PyBuffer\nAnything PyRef","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"See below for an explanation of the Py* types (PyList, PyIO, etc).","category":"page"},{"location":"conversion-to-julia/#python-wrappers","page":"Conversion to Julia","title":"Wrapper types","text":"","category":"section"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"The following types wrap a Python object, giving it the semantics of a Julia object. For example PyList(x) interprets the Python sequence x as a Julia abstract vector.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"Apart from a few fundamental immutable types, conversion from Python to Julia Any will return a wrapper type such as one of these, or simply Py if no wrapper type is suitable.","category":"page"},{"location":"conversion-to-julia/","page":"Conversion to Julia","title":"Conversion to Julia","text":"PyList\nPySet\nPyDict\nPyIterable\nPyArray\nPyIO\nPyTable\nPyPandasDataFrame\nPyObjectArray\nPyException","category":"page"},{"location":"conversion-to-julia/#PythonCall.PyList","page":"Conversion to Julia","title":"PythonCall.PyList","text":"PyList{T=Py}([x])\n\nWraps the Python list x (or anything satisfying the sequence interface) as an AbstractVector{T}.\n\nIf x is not a Python object, it is converted to one using pylist.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PySet","page":"Conversion to Julia","title":"PythonCall.PySet","text":"PySet{T=Py}([x])\n\nWraps the Python set x (or anything satisfying the set interface) as an AbstractSet{T}.\n\nIf x is not a Python object, it is converted to one using pyset.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyDict","page":"Conversion to Julia","title":"PythonCall.PyDict","text":"PyDict{K=Py,V=Py}([x])\n\nWraps the Python dict x (or anything satisfying the mapping interface) as an AbstractDict{K,V}.\n\nIf x is not a Python object, it is converted to one using pydict.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyIterable","page":"Conversion to Julia","title":"PythonCall.PyIterable","text":"PyIterable{T=Py}(x)\n\nThis object iterates over iterable Python object x, yielding values of type T.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyArray","page":"Conversion to Julia","title":"PythonCall.PyArray","text":"PyArray{T,N,M,L,R}(x; copy=true, array=true, buffer=true)\n\nWrap the Python array x as a Julia AbstractArray{T,N}.\n\nThe input x can be bytes, bytearray, array.array, numpy.ndarray or anything satisfying the buffer protocol (if buffer=true) or the numpy array interface (if array=true).\n\nIf copy=false then the resulting array is guaranteed to directly wrap the data in x. If copy=true then a copy is taken if necessary to produce an array.\n\nThe type parameters are all optional, and are:\n\nT: The element type.\nN: The number of dimensions.\nM: True if the array is mutable.\nL: True if the array supports fast linear indexing.\nR: The element type of the underlying buffer. Equal to T for scalar numeric types.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyIO","page":"Conversion to Julia","title":"PythonCall.PyIO","text":"PyIO(x; own=false, text=missing, buflen=4096)\n\nWrap the Python IO stream x as a Julia IO stream.\n\nWhen this goes out of scope and is finalized, it is automatically flushed. If own=true then it is also closed.\n\nIf text=false then x must be a binary stream and arbitrary binary I/O is possible. If text=true then x must be a text stream and only UTF-8 must be written (i.e. use print not write). If text is not specified then it is chosen automatically. If x is a text stream and you really need a binary stream, then often PyIO(x.buffer) will work.\n\nFor efficiency, reads and writes are buffered before being sent to x. The size of the buffers is buflen. The buffers are cleared using flush.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyTable","page":"Conversion to Julia","title":"PythonCall.PyTable","text":"PyTable\n\nAbstract type for Python wrappers which may be interpretable as Tables.jl-compatible tables.\n\nIf pyconvert(PyTable, x::Py) is a table, then x is also a table.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyPandasDataFrame","page":"Conversion to Julia","title":"PythonCall.PyPandasDataFrame","text":"PyPandasDataFrame(x; indexname=nothing, columntypes=Dict())\n\nWraps the pandas DataFrame x as a Tables.jl-compatible table.\n\nindexname is the name of the column to contain the index. It may be nothing to exclude the index.\n\ncolumntypes is a mapping of column names to column element types, in case automatic deduction does not work.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyObjectArray","page":"Conversion to Julia","title":"PythonCall.PyObjectArray","text":"PyObjectArray(undef, dims...)\nPyObjectArray(array)\n\nAn array of Pys which supports the Python buffer protocol.\n\nInternally, the objects are stored as an array of pointers.\n\n\n\n\n\n","category":"type"},{"location":"conversion-to-julia/#PythonCall.PyException","page":"Conversion to Julia","title":"PythonCall.PyException","text":"PyException(x)\n\nWraps the Python exception x as a Julia Exception.\n\n\n\n\n\n","category":"type"},{"location":"pycall/#Comparison-with-PyCall","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"","category":"section"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"Another similar interface to Python is provided by PyCall. Here we note some key differences.","category":"page"},{"location":"pycall/#Flexibility-of-conversion","page":"Comparison with PyCall","title":"Flexibility of conversion","text":"","category":"section"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"In PyCall you do convert(T, x) to convert the Python object x to a Julia T. In PythonCall you similarly do pyconvert(T, x).","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"PythonCall supports far more combinations of types of T and x. For example convert(Vector, x) in PyCall requires x to be a sequence, whereas in PythonCall pyconvert(Vector, x) works if x is an iterable, an object supporting the buffer protocol (such as bytes) or an object supporting the numpy array interface (such as numpy.ndarray).","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"Furthermore, pyconvert can be extended to support more types, whereas convert(Vector, x) cannot support more Python types.","category":"page"},{"location":"pycall/#Lossiness-of-conversion","page":"Comparison with PyCall","title":"Lossiness of conversion","text":"","category":"section"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"Both packages allow conversion of Julia values to Python: PyObject(x) in PyCall, Py(x) in PythonCall.","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"Whereas both packages convert numbers, booleans, tuples and strings to their Python counterparts, they differ in handling other types. For example PyCall converts AbstractVector to list whereas PythonCall converts AbstractVector to juliacall.VectorValue which is a sequence type directly wrapping the Julia value - this has the advantage that mutating the Python object also mutates the original Julia object.","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"Hence with PyCall the following does not mutate the original array x:","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"x = [\"foo\", \"bar\"]\nPyObject(x).append(\"baz\")\n@show x # --> [\"foo\", \"bar\"]","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"whereas with PythonCall the following does mutate x:","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"x = [\"foo\", \"bar\"]\nPy(x).append(\"baz\")\n@show x # --> [\"foo\", \"bar\", \"baz\"]","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"In fact, PythonCall has the policy that any mutable object will by default be wrapped in this way, which not only preserves mutability but makes conversion faster for large containers since it does not require taking a copy of all the data.","category":"page"},{"location":"pycall/#Automatic-conversion","page":"Comparison with PyCall","title":"Automatic conversion","text":"","category":"section"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"In PyCall, most function calls, attribute accesses, indexing, etc. of Python object by default automatically convert their result to a Julia object. This means that the following","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"pyimport(\"sys\").modules[\"KEY\"] = \"VALUE\"","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"does not actually modify the modules dict because it was copied to a new Julia Dict. This was probably not intended, plus it wasted time copying the whole dictionary. Instead you must do","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"set!(pyimport(os).\"environ\", \"KEY\", \"VALUE\")","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"In PythonCall, we don't do any such automatic conversion: we always return Py. This means that the first piece of code above does what you think.","category":"page"},{"location":"pycall/#Which-Python","page":"Comparison with PyCall","title":"Which Python","text":"","category":"section"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"PyCall uses some global installation of Python - typically the version of Python installed on the system or used by Conda.","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"PythonCall uses a separate Conda environment for each Julia environment/project/package and installs Python (and other Python packages) into that. This means that different Julia projects can maintain an isolated set of Python dependencies (including the Python version itself).","category":"page"},{"location":"pycall/#Corresponding-Python-packages","page":"Comparison with PyCall","title":"Corresponding Python packages","text":"","category":"section"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"PyCall has the corresponding Python package pyjulia for calling Julia from Python, and PythonCall similarly has juliacall.","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"One difference is between them is their code size: pyjulia is a large package, whereas juliacall is very small, with most of the implementation being in PythonCall itself. The practical up-shot is that PythonCall/juliacall have very symmetric interfaces; for example they use identical conversion policies and have the same set of wrapper types available.","category":"page"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"Note also that juliacall will use a separate Julia project for each virtual/conda environment. This means that different Python environments can maintain an isolated set of Julia dependencies, including the versions of Julia and PythonCall themselves.","category":"page"},{"location":"pycall/#Compatability","page":"Comparison with PyCall","title":"Compatability","text":"","category":"section"},{"location":"pycall/","page":"Comparison with PyCall","title":"Comparison with PyCall","text":"PyCall supports Julia 0.7+ and Python 2.7+, whereas PythonCall supports Julia 1.0+ and Python 3.5+. PyCall requires numpy to be installed, PythonCall doesn't (it provides the same fast array access through the buffer protocol and array interface).","category":"page"}]
}
